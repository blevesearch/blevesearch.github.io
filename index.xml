<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bleve</title>
    <link>https://www.blevesearch.com/</link>
    <description>Recent content on Bleve</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© &lt;a href=&#34;http://couchbase.com/&#34;&gt;Couchbase&lt;/a&gt; 2015-2016</copyright>
    <lastBuildDate>Mon, 29 Oct 2018 10:25:38 -0400</lastBuildDate>
    <atom:link href="https://www.blevesearch.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go Israel Meetup</title>
      <link>https://www.blevesearch.com/events/goIsrael2018/</link>
      <pubDate>Mon, 29 Oct 2018 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/events/goIsrael2018/</guid>
      <description>&lt;p&gt;Bleve&lt;/p&gt;

&lt;p&gt;In this talk we&amp;rsquo;ll start with an overview of the functionality provided by Bleve. Next we&amp;rsquo;ll look at some examples of how you can integrate Bleve with your Go applications. Finally, we&amp;rsquo;ll talk about Scorch, the latest index scheme used by Bleve, and how it fits into the future of the project.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.meetup.com/Go-Israel/events/255070274/&#34;&gt;Go Israel&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GopherCon UK</title>
      <link>https://www.blevesearch.com/events/gopherConUk2018/</link>
      <pubDate>Fri, 03 Aug 2018 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/events/gopherConUk2018/</guid>
      <description>&lt;p&gt;Scorch! a New Index for Bleve&lt;/p&gt;

&lt;p&gt;Bleve, an open-source full-text search library for Go, has moved beyond the general-purpose key/value store and now implements its own custom binary index format named Scorch. Learn about the data-structures and Go libraries we&amp;rsquo;ve chosen to build this solution.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.gophercon.co.uk/&#34;&gt;GopherCon UK&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zürich Gophers</title>
      <link>https://www.blevesearch.com/events/meetupZurich2016/</link>
      <pubDate>Thu, 20 Oct 2016 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/events/meetupZurich2016/</guid>
      <description>&lt;p&gt;My first time to Zürich!  I&amp;rsquo;m now confirmed to be speaking about Bleve at
the &lt;a href=&#34;https://www.meetup.com/Zurich-Gophers/events/233262687/&#34;&gt;Zürich Gophers meetup&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang Paris</title>
      <link>https://www.blevesearch.com/events/meetupParis2016/</link>
      <pubDate>Sun, 09 Oct 2016 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/events/meetupParis2016/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m now confirmed to be speaking about Bleve at the &lt;a href=&#34;http://www.meetup.com/Golang-Paris/events/234263218/&#34;&gt;The GIG : Gathering of International Gophers&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using blevex packages</title>
      <link>https://www.blevesearch.com/docs/Blevex/</link>
      <pubDate>Wed, 21 Sep 2016 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/docs/Blevex/</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://github.com/blevesearch/blevex&#34;&gt;blevex&lt;/a&gt; repository contains optional add-ons to bleve which cannot be a part of the main repository for the following reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C dependency&lt;/li&gt;
&lt;li&gt;Does not fully satisfy interface contracts&lt;/li&gt;
&lt;li&gt;Experimental in nature&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;using-blevex-packages:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;Using blevex packages&lt;/h3&gt;

&lt;p&gt;Bleve does not directly import any of the sub-packages with the blevex repository.  If your application would like to use one of these packages, they can either import the package directly, or import the bleve config package, which then adds the ability to include blevex packages through common build-tags.&lt;/p&gt;

&lt;p&gt;For example, if your application adds:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import(
  _ &amp;quot;github.com/blevesearch/bleve/config&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then when you build your application, it will automatically recognize a common set of build tags, which currently includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cellar&lt;/li&gt;
&lt;li&gt;cld2&lt;/li&gt;
&lt;li&gt;cznicb&lt;/li&gt;
&lt;li&gt;forestdb&lt;/li&gt;
&lt;li&gt;icu&lt;/li&gt;
&lt;li&gt;kagome&lt;/li&gt;
&lt;li&gt;leveldb&lt;/li&gt;
&lt;li&gt;libstemmer&lt;/li&gt;
&lt;li&gt;rocksdb&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;kv-stores:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;KV Stores&lt;/h3&gt;

&lt;h4 id=&#34;cellar:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;cellar&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/couchbaselabs/cellar&#34;&gt;Cellar&lt;/a&gt; is an experimental KVStore implementation.&lt;/p&gt;

&lt;h4 id=&#34;cznicb:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;cznicb&lt;/h4&gt;

&lt;p&gt;Bleve supports using &lt;a href=&#34;https://github.com/cznic/b&#34;&gt;cznic/b&lt;/a&gt; as a KVStore implementation.  Although this implementation is pure Go, it does not offer reader isolation, so it does not fully satisfy the bleve interface requirements.  Under certain restrictions it can still be used safely.&lt;/p&gt;

&lt;h4 id=&#34;forestdb:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;forestdb&lt;/h4&gt;

&lt;p&gt;Bleve supports using &lt;a href=&#34;https://github.com/couchbase/forestdb&#34;&gt;ForestDB&lt;/a&gt; as a KVStore implementation.  This requires a C/C++ dependency, please see &lt;a href=&#34;https://www.blevesearch.com/docs/Building/&#34;&gt;Building&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;leveldb:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;leveldb&lt;/h4&gt;

&lt;p&gt;Bleve supports using &lt;a href=&#34;https://code.google.com/p/leveldb/&#34;&gt;LevelDB&lt;/a&gt; as a KVStore implementation.  This requires a C/C++ dependency, please see &lt;a href=&#34;https://www.blevesearch.com/docs/Building/&#34;&gt;Building&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;rocksdb:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;rocksdb&lt;/h4&gt;

&lt;p&gt;Bleve supports using &lt;a href=&#34;https://github.com/facebook/rocksdb&#34;&gt;RocksDB&lt;/a&gt; as a KVStore implementation.  This requires a C/C++ dependency, please see &lt;a href=&#34;https://www.blevesearch.com/docs/Building/&#34;&gt;Building&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tokenizers:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;Tokenizers&lt;/h3&gt;

&lt;h4 id=&#34;icu:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;ICU&lt;/h4&gt;

&lt;p&gt;Bleve supports using the &lt;a href=&#34;http://site.icu-project.org/&#34;&gt;ICU&lt;/a&gt; project to tokenize words.  For most languages Bleve&amp;rsquo;s built-in unicode segmentation will work fine.  However, languages which require dictionary-based segmentation may still require this library.  This requires a C/C++ dependency, please see &lt;a href=&#34;https://www.blevesearch.com/docs/Building/&#34;&gt;Building&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;NOTE: It is recommended to get the most recent version of ICU possible.  Older versions often included with distributions do not support language based tokenization.&lt;/p&gt;

&lt;h3 id=&#34;token-filters:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;Token Filters&lt;/h3&gt;

&lt;h4 id=&#34;detect-lang:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;detect_lang&lt;/h4&gt;

&lt;p&gt;Bleve supports using the &lt;a href=&#34;https://code.google.com/p/cld2/&#34;&gt;cld2&lt;/a&gt; library to determine the language of a sample of text.  This is implemented as a token filter which will return the result as a ISO 639 language code.  This requires a C/C++ dependency, please see &lt;a href=&#34;https://www.blevesearch.com/docs/Building/&#34;&gt;Building&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;stemmer-filter:34a97ce3c17c3c82af8fae1291afb5f9&#34;&gt;stemmer_filter&lt;/h4&gt;

&lt;p&gt;Bleve supports using the &lt;a href=&#34;http://snowball.tartarus.org/download.php&#34;&gt;libstemmer&lt;/a&gt; library to stem words for many languages.  Many of the language specific analyzers depend on this library.  This requires a C/C++ dependency, please see &lt;a href=&#34;https://www.blevesearch.com/docs/Building/&#34;&gt;Building&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Index Aliases</title>
      <link>https://www.blevesearch.com/docs/IndexAlias/</link>
      <pubDate>Wed, 21 Sep 2016 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/docs/IndexAlias/</guid>
      <description>

&lt;p&gt;Bleve has a powerful feature called an &lt;code&gt;IndexAlias&lt;/code&gt;.  The IndexAlias can be used to search an index, with the additional ability to atomically switch the underlying physical index.  IndexAliases can also be search to search across multiple indexes at the same time and correctly merge the results.&lt;/p&gt;

&lt;h3 id=&#34;indexalias-interface:6dfd36eb1af3597f02acd82624b49c37&#34;&gt;IndexAlias Interface&lt;/h3&gt;

&lt;p&gt;First, its useful to note that thanks to Go interfaces, an IndexAlias is also an Index.  This means that in general you work with an IndexAlias just as you would work with an Index.  The alias concept also adds 3 methods:  Add(), Remove(), and Swap()&lt;/p&gt;

&lt;p&gt;Add, will add one or more indexes to the alias.
Remove will remove one or more indexes from the alias.
Swap will atomically add/remove the provided indexes.  (all other ops, like search will see the alias before or after all adds/removes are done)&lt;/p&gt;

&lt;h3 id=&#34;switching-indexes-with-zero-downtime:6dfd36eb1af3597f02acd82624b49c37&#34;&gt;Switching Indexes with Zero Downtime&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Create a new Index&lt;/li&gt;
&lt;li&gt;Create an IndexAlias pointing to the Index&lt;/li&gt;
&lt;li&gt;Write your application to query the IndexAlias&lt;/li&gt;
&lt;li&gt;&amp;hellip;At some later time, create a new Index&lt;/li&gt;
&lt;li&gt;Call Swap() on the IndexAlias passing in the new Index&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Your application will safely switch to searching the new index.&lt;/p&gt;

&lt;h3 id=&#34;searching-across-multiple-indexes:6dfd36eb1af3597f02acd82624b49c37&#34;&gt;Searching Across Multiple Indexes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Create more than one Index&lt;/li&gt;
&lt;li&gt;Create the IndexAlias pointing to these indexes&lt;/li&gt;
&lt;li&gt;Writer your application to invoke Search() on the IndexAlias&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Your application will search across all the underlying indexes at the same time, and the results will be merged together into a single result.&lt;/p&gt;

&lt;h4 id=&#34;limitations:6dfd36eb1af3597f02acd82624b49c37&#34;&gt;Limitations&lt;/h4&gt;

&lt;p&gt;When and IndexAlias points to multiple indexes not all operations are supported.  Only operations which can be invoked on all the child indexes and have their responses aggregated are supported.  Operations that are not supported return &lt;code&gt;bleve.ErrorAliasMulti&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sorting</title>
      <link>https://www.blevesearch.com/docs/Sorting/</link>
      <pubDate>Wed, 21 Sep 2016 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/docs/Sorting/</guid>
      <description>

&lt;p&gt;Bleve now gives you the ability to customize the order of your search results.&lt;/p&gt;

&lt;p&gt;The default behavior is to sort results by relevance, with the highest scoring results first.&lt;/p&gt;

&lt;h3 id=&#34;simple-api:fe8eddd7d5918bd09eccd8eff0078748&#34;&gt;Simple API&lt;/h3&gt;

&lt;p&gt;The simple API adds a &lt;code&gt;SortBy()&lt;/code&gt; method to the SearchRequest.  Here is an example which sorts by the field &lt;code&gt;age&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;searchRequest.SortBy([]string{&amp;quot;age&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The argument is an array of strings.  Each string refers to the name of a field.  The names of fields can be prefixed with the &lt;code&gt;-&lt;/code&gt; character, which will cause that field to be reversed (descending order).  Items will first be sorted by the first field.  Any items with the same value for that field, are then also sorted by the next field, and so on.  All fields in the sort order &lt;strong&gt;MUST&lt;/strong&gt; be indexed.&lt;/p&gt;

&lt;p&gt;There are two special fields defined for use:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_id&lt;/code&gt; - refers to the document identifier&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_score&lt;/code&gt; - refers to the relevance score computed by Bleve&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is a more complex example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;searchRequest.SortBy([]string{&amp;quot;age&amp;quot;, &amp;quot;-_score&amp;quot;, &amp;quot;_id&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will first sort results by the &amp;ldquo;age&amp;rdquo; field.  If two documents have the same value for this field, they will then be sorted by the score descending, finally, if documents have the same age and score, they will be sorted by document ID ascending.&lt;/p&gt;

&lt;h3 id=&#34;advanced-api:fe8eddd7d5918bd09eccd8eff0078748&#34;&gt;Advanced API&lt;/h3&gt;

&lt;p&gt;The simple API works for most cases, but there are some which require the advanced API.  In these cases you must import the bleve &lt;code&gt;search&lt;/code&gt; sub-package, and build a &lt;code&gt;search.SortOrder&lt;/code&gt; object.  This is a slice of &lt;code&gt;search.SearchSort&lt;/code&gt; objects.  Today there are three implementations available, SortField, SortScore, and SortDocID.&lt;/p&gt;

&lt;p&gt;By building these structures manually, you can avoid ambiguities and limitations of the simple API.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sort by fields which happen to start with &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Sort by fields which happen to conflict with &lt;code&gt;_id&lt;/code&gt; or &lt;code&gt;_score&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Control whether documents missing a field value should sort first or last&lt;/li&gt;
&lt;li&gt;Control which value for multi-value fields should be used for sorting&lt;/li&gt;
&lt;li&gt;Force handling field values as a particular type (defaults to auto)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>dotGo</title>
      <link>https://www.blevesearch.com/events/dotGo2015/</link>
      <pubDate>Mon, 09 Nov 2015 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/events/dotGo2015/</guid>
      <description>&lt;p&gt;We&amp;rsquo;re back!  I tried something a little bit different in this talk, I explored the unique way that contributors have shaped the project.  The dotGo conference delivered a day full of great talks, I encourage you to &lt;a href=&#34;http://www.thedotpost.com/conference/dotgo-2015&#34;&gt;check out all of them&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Discussion @ &lt;a href=&#34;http://www.thedotpost.com/2015/11/marty-schoch-a-tour-of-the-bleve&#34;&gt;The dot Post&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Video:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/OynPw4aOlV0&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Slides:&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;5deddf2a4c67446e9d8526cc19fe6e13&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Index Structure</title>
      <link>https://www.blevesearch.com/docs/Index-Structure/</link>
      <pubDate>Fri, 09 Oct 2015 00:00:00 +0100</pubDate>
      
      <guid>https://www.blevesearch.com/docs/Index-Structure/</guid>
      <description>

&lt;p&gt;Bleve default index, called &amp;ldquo;upside_down&amp;rdquo; is stored in a single key/value store
table. The store must be able to enumerate its entries starting at a given key,
in lexicographic byte order.&lt;/p&gt;

&lt;p&gt;Index key and values are handled as byte arrays and are called rows (see &lt;code&gt;index/upside_down/row.go&lt;/code&gt; for details). To store different row types in a single table, bleve prefixes their keys with a single byte, for instance the term frequency keys start with a &amp;rsquo;t&amp;rsquo;. The following sections describe the data structures stored in the index with pseudo-Go code for value layout.&lt;/p&gt;

&lt;h3 id=&#34;version-row:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Version Row&lt;/h3&gt;

&lt;p&gt;Key: &lt;code&gt;&amp;quot;v&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
	Version uint8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only one version row exists in the index and is used to check version compatibility&lt;/p&gt;

&lt;h3 id=&#34;field-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Field Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;f&amp;quot;&lt;/code&gt;, &lt;code&gt;fieldIndex&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
	Name string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They map field qualified names to internal integer indices. The field names are only used or displayed at API level, bleve uses the indices everywhere internally.&lt;/p&gt;

&lt;h3 id=&#34;dictionary-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Dictionary Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;d&amp;quot;&lt;/code&gt;, &lt;code&gt;fieldIndex&lt;/code&gt;, &lt;code&gt;term&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
	Count uint64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dictionary rows index (field, term) pairs and count the number of documents containing them. Range queries over terms of a given field, which includes prefix queries, are implemented by seeking over dictionary rows first.&lt;/p&gt;

&lt;h3 id=&#34;term-frequency-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Term Frequency Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;t&amp;quot;&lt;/code&gt;, &lt;code&gt;fieldIndex&lt;/code&gt;, &lt;code&gt;term&lt;/code&gt;, &lt;code&gt;docId&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type TermFrequencyRow struct {
	Freq    uint64
	Norm    float32
	Vectors []struct{
		Field          uint16
		ArrayPositions []uint64
		Pos            uint64
		Start          uint64
		End            uint64
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Term frequency rows store statistics about a term in a document field. Applications using result highlighting or phrase search must also record term locations by setting &lt;code&gt;IncludeTermVectors&lt;/code&gt; in the field mapping. Term locations are used to retrieve the term origin in the source document or measure terms proximity.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Freq&lt;/code&gt; is the number of occurrences of the term in the field.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Norm&lt;/code&gt; is 1/sqrt(number of tokens in the field). This factor helps balancing scores of shorter documents which have lower term frequencies.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vectors&lt;/code&gt; is filled if &lt;code&gt;IncludeTermVectors&lt;/code&gt; is set in the field mapping. Each element describes a single occurrence of the term in the source document. &lt;code&gt;Field&lt;/code&gt; is the field index, and is the same as in the row key except for composite fields where it references the source field (composite fields like &lt;code&gt;_all&lt;/code&gt; are made of the union of other fields). Because documents are structured as trees and intermediate elements can be arrays or slices, the field index is sometimes not enough to resolve a value. The indices of the value or some of its ancestors into those arrays or slices are also required. They are stored in &lt;code&gt;ArrayPositions&lt;/code&gt;. &lt;code&gt;Pos&lt;/code&gt; tells the entry is the &lt;code&gt;Pos&lt;/code&gt;-th occurrence of the term in the field (starting at 1). &lt;code&gt;Start&lt;/code&gt; and &lt;code&gt;End&lt;/code&gt; are the byte offsets of the source of the term in the field value.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;back-index-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Back Index Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt;, &lt;code&gt;docId&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
    Indexed []struct{
		Term []byte
		Field uint32
	},
	Stored []struct{
		Field uint32
		ArrayPositions []uint64
	},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Back index rows describe the indexed and stored terms of a document. &lt;code&gt;Field&lt;/code&gt; is the field index and &lt;code&gt;ArrayPositions&lt;/code&gt; is explained in Term frequency rows section.&lt;/p&gt;

&lt;h3 id=&#34;stored-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Stored Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;s&amp;quot;&lt;/code&gt;, &lt;code&gt;docId&lt;/code&gt;, &lt;code&gt;fieldId&lt;/code&gt;, &lt;code&gt;arrayPositions&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
	Value []byte
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Stored rows contains the values of document fields which mapping had the &lt;code&gt;Store&lt;/code&gt; property. &lt;code&gt;arrayPositions&lt;/code&gt; meaning is described in Term frequency rows section.&lt;/p&gt;

&lt;h3 id=&#34;internal-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Internal Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;i&amp;quot;&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
    Value []byte
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Internal rows are used to store arbitrary data in the index.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deferred Cleanup, Checking Errors, and Potential Problems</title>
      <link>https://www.blevesearch.com/news/Deferred-Cleanup,-Checking-Errors,-and-Potential-Problems/</link>
      <pubDate>Mon, 28 Sep 2015 10:40:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/news/Deferred-Cleanup,-Checking-Errors,-and-Potential-Problems/</guid>
      <description>

&lt;p&gt;The &lt;em&gt;defer&lt;/em&gt; statement in Go is frequently used to ensure that once a resource has been acquired, it will be properly cleaned up.  In its simplest form it works exactly as you expect.  But, as you move to more advanced usages there are some things to watch out for.  I&amp;rsquo;d like to share one that I recently ran into while writing Bleve test cases.&lt;/p&gt;

&lt;h3 id=&#34;basics:ffe76477ce26feb5927595f82ec07acf&#34;&gt;Basics&lt;/h3&gt;

&lt;p&gt;The power of the &lt;em&gt;defer&lt;/em&gt; statement in Go is that it lets you put the acquisition and cleanup of a resource side by side.  When you read code later, it&amp;rsquo;s easy to see that the correct behavior is guaranteed.  Let&amp;rsquo;s take a look at a simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer r.Close()
}

type Resource struct {
	name string
}

func Open(name string) (*Resource, error) {
	return &amp;amp;Resource{name}, nil
}

func (r *Resource) Close() error {
	log.Printf(&amp;quot;closing %s\n&amp;quot;, r.name)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/fYB2alVcIw&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The main function shows some very common behavior.  Open a resource, check for an error, then &lt;em&gt;defer&lt;/em&gt; Closing the resource.  When we run this, we get the expected behavior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing a
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;opening-another-resource-reusing-the-variable:ffe76477ce26feb5927595f82ec07acf&#34;&gt;Opening another Resource, Reusing the Variable&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s make the example a bit more complex.  Now, after closing the resource, we will open another one (with a different name).  Can we reuse the same variable?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer r.Close()

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer r.Close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/Bal_y0nv4U&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When I was new to Go and first encountered this code I wasn&amp;rsquo;t sure if this would work.  I knew that &lt;em&gt;defer&lt;/em&gt; would not execute until the end of main, but would it close &amp;lsquo;a&amp;rsquo; AND &amp;lsquo;b&amp;rsquo;?  Or would it close &amp;lsquo;b&amp;rsquo; twice?  If we run it we see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing b
2009/11/10 23:00:00 closing a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, it does work, this is the expected output.  Some of you may be wondering, but &lt;em&gt;why&lt;/em&gt; does it work?  As the Go blog &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34;&gt;Defer, Panic, and Recover&lt;/a&gt; explains,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A deferred function&amp;rsquo;s arguments are evaluated when the defer statement is evaluated.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In our case, the method receiver &amp;lsquo;r&amp;rsquo; for the Close() method behaves just like an argument.  So the &amp;lsquo;r&amp;rsquo; is evaluated at the time the defer statement is evaluated, and &lt;em&gt;NOT&lt;/em&gt; when the statement is executed.  In Bleve code we saw this pattern occur frequently in test cases.  We would acquire a resource, take some action, close the resource, check the state of things, then repeat the process.&lt;/p&gt;

&lt;h3 id=&#34;errcheck:ffe76477ce26feb5927595f82ec07acf&#34;&gt;errcheck?&lt;/h3&gt;

&lt;p&gt;Last February I had the amazing opportunity to attend &lt;a href=&#34;http://www.gophercon.in/&#34;&gt;GopherCon India&lt;/a&gt;.  One of the many things I learned while there was of a tool called &lt;a href=&#34;https://github.com/kisielk/errcheck&#34;&gt;errcheck&lt;/a&gt;.  The idea of the tool is simple, it looks at your Go code and identifies places where you&amp;rsquo;re not checking a returned error.  This seemed like such an obvious thing to do, so I ran it on the entire Bleve codebase.  We found several clear cases where an error was returned, and we would not propagate the error back to the caller.&lt;/p&gt;

&lt;p&gt;But what happens if we run &lt;em&gt;errcheck&lt;/em&gt; on the code we just wrote above?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github.com/mschoch/defertest/main.go:10:15	defer r.Close()
github.com/mschoch/defertest/main.go:16:15	defer r.Close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Close() method returns an error.  Although it&amp;rsquo;s not used in this contrived example, I coded it that way on purpose as that is very common in the real world.  Does checking this error matter?  If closing the first resource results in an error, should you try to close the second one?  In the abstract these are interesting philosophical questions, but let&amp;rsquo;s assume we do want to check the errors.  How would we do it?  My first attempt looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer func() {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer func() {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/_MPUl6zWjF&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I added an anonymous function which invokes r.Close(), checks the error, and if its non-nil we exit the program through log.Fatal().  It seems like such a simple change, but we&amp;rsquo;ve introduced a severe bug into the code.  In our case we can see it clearly since we&amp;rsquo;re printing out the name of the resource being closed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing b
2009/11/10 23:00:00 closing b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oops!  We&amp;rsquo;re now closing the &amp;lsquo;b&amp;rsquo; resource twice, and never closing the &amp;lsquo;a&amp;rsquo; resource.  This is a severe problem, closing &amp;lsquo;b&amp;rsquo; a second time may not be well defined behavior, and not closing &amp;lsquo;a&amp;rsquo; may leak resources.&lt;/p&gt;

&lt;p&gt;Where did we go wrong?  Remember the rule we were given was:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A deferred function&amp;rsquo;s arguments are evaluated when the defer statement is evaluated.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And in our new code, the deferred function has no arguments, and no method receiver.  We&amp;rsquo;re now relying the anonymous function referring to &amp;lsquo;r&amp;rsquo;.  The Go spec says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;rdquo;&amp;hellip;they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, now it&amp;rsquo;s fairly clear what happened.  At the time the &lt;em&gt;defer&lt;/em&gt; statement was evaluated, the arguments were evaluated, but there were none.  Then at the end of the function, the deferred function is executed, and &lt;em&gt;now&lt;/em&gt; as the anonymous functions are executed, &amp;lsquo;r&amp;rsquo; is evaluated, and in both cases it refers to &amp;lsquo;b&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;the-fix:ffe76477ce26feb5927595f82ec07acf&#34;&gt;The Fix&lt;/h3&gt;

&lt;p&gt;Option 1, we can rewrite the &lt;em&gt;defer&lt;/em&gt; statement to pass &amp;lsquo;r&amp;rsquo; as an argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer func(r *Resource) {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}(r)

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer func(r *Resource) {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}(r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This does give the correct output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing b
2009/11/10 23:00:00 closing a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But, to be honest, it&amp;rsquo;s rather verbose.  In many cases it may just be simpler to use a different variable name.  Option 2, use a new variable for the second resource:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer func() {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()

	r2, err := Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer func() {
		err := r2.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;UPDATE: 2015-09-29&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Users &lt;a href=&#34;https://www.reddit.com/r/golang/comments/3mqxar/deferred_cleanup_checking_errors_and_potential/&#34;&gt;discussing this on Reddit&lt;/a&gt; proposed a third option.  Create a named cleanup function and use the existing io.Closer interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer Close(r)

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer Close(r)
}

func Close(c io.Closer) {
	err := c.Close()
	if err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/ZjlavK1r6N&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As I mentioned earlier, in Bleve this pattern only seems to arise in test cases.  I suspect in real code you&amp;rsquo;d be more likely to already be using more descriptive identifiers.&lt;/p&gt;

&lt;h3 id=&#34;summary:ffe76477ce26feb5927595f82ec07acf&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;To me the lesson here is that we had a simple pattern for deferred cleanup that worked.  I even explicitly took the time to verify that it cleaned up the correct resources when I reused variables.  Then I took the seemingly natural step to make sure we check all the returned errors.  But, I was a bit careless and overlooked that the deferred anonymous function can have significantly different behavior.  It wasn&amp;rsquo;t until I observed problems that I went back to recheck my assumptions and track down the problem.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Faster Tokenization with Ragel generated FSM</title>
      <link>https://www.blevesearch.com/news/Faster-Tokenization-with-Ragel-generated-FSM/</link>
      <pubDate>Tue, 08 Sep 2015 10:40:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/news/Faster-Tokenization-with-Ragel-generated-FSM/</guid>
      <description>

&lt;p&gt;Text processed by Bleve must first go through the process of tokenization.  Read on to learn how we sped up the process by a factor of 2x by introducing an FSM generated by &lt;a href=&#34;https://www.colm.net/open-source/ragel/&#34;&gt;Ragel&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tokenization:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Tokenization?&lt;/h3&gt;

&lt;p&gt;Tokenization is the process by which we take a string like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;Using Ragel to tokenize 2.1x faster.&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And turn it into discrete tokens:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;Using&amp;quot;, &amp;quot;Ragel&amp;quot;, &amp;quot;to&amp;quot;, &amp;quot;tokenize&amp;quot;, &amp;quot;2.1x&amp;quot;, &amp;quot;faster&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Your first thought might be that we can simply split the text up using the Unicode White Space property.  And for simple use cases that might be good enough, but you still have to handle removing punctuation.  Unicode defines properties for that as well, but if we want to retain &lt;code&gt;2.1x&lt;/code&gt; as is, we can&amp;rsquo;t simply remove all punctuation.  Fortunately, the Unicode specification has already addressed this problem and defined rules for word segmentation.&lt;/p&gt;

&lt;h3 id=&#34;unicode-text-segmentation:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Unicode Text Segmentation&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;re interested in all details, see &lt;a href=&#34;http://unicode.org/reports/tr29/&#34;&gt;Unicode® Standard Annex #29&lt;/a&gt;.  What matters for this discussion is that it defines a set of rules, based on which characters occur before and after others, to decide whether or not to break up the text.&lt;/p&gt;

&lt;p&gt;Our first solution was simply to integrate with the C library &lt;a href=&#34;http://site.icu-project.org/&#34;&gt;ICU&lt;/a&gt;.  This got us up and running quickly, but having a dependency on ICU was not a long term solution.&lt;/p&gt;

&lt;p&gt;Next, I set out to write my own implementation.  I followed the lead I found in the Go standard library&amp;rsquo;s &lt;a href=&#34;https://github.com/golang/go/tree/master/src/unicode&#34;&gt;unicode package&lt;/a&gt;, and wrote code which generated &lt;code&gt;unicode.RangeTable&lt;/code&gt;s for all the properties defined by the word segmentation rules.  Next, I wrote a for loop which walked through the slice of bytes, kept track of which types of characters occurred in sequence, and returned the segmented text at the appropriate places.  Fortunately, the Unicode specification also includes test cases, so after banging on the code for a while I had something that worked.&lt;/p&gt;

&lt;p&gt;While it was great that it was working, it had some serious drawbacks.  First, if the rules evolve in a newer Unicode spec, updating this code base could be tricky.  Second, while it performed good enough to use, I always knew that the for-loops and Unicode range table lookups were not optimal.&lt;/p&gt;

&lt;h3 id=&#34;a-generated-fsm-solution:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;A Generated FSM Solution&lt;/h3&gt;

&lt;p&gt;The appeal of a generated FSM solution was that we could keep the rule definitions at a high level.  This lets us easily modify them as they change, and it also allows for the possibility of customization in the future.  Second, the generated code should be able to take advantage of well understood FSM techniques and perform faster than my hand-rolled for-loop.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve gone looking for FSM solutions in the Go ecosystem in the past and never found one that seemed to meet my needs.  This time however, I came across someone suggesting &lt;a href=&#34;https://www.colm.net/open-source/ragel/&#34;&gt;Ragel&lt;/a&gt;.  To be honest, approaching a project like this can be daunting.  Just looking at the example on their home page you realize you have to learn their DSL.  Sure it&amp;rsquo;s rooted in regular-expressions, but the full syntax goes beyond that.  The documentation looked solid, but I still wondered, how good is Go code generator?  The code isn&amp;rsquo;t on github and there doesn&amp;rsquo;t appear to be any community around it. Am I going to invest a day learning this just to hit some dead end?&lt;/p&gt;

&lt;p&gt;I was desperate, so I dove in despite my concerns&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;ragel:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Ragel&lt;/h3&gt;

&lt;p&gt;I started by trying to write a test program, just to get comfortable writing rules in Ragel and generating Go code.  I came across this project &lt;a href=&#34;https://github.com/acsellers/ragel-go-examples&#34;&gt;ragel-go-examples&lt;/a&gt;, which I recommend to anyone else getting started.&lt;/p&gt;

&lt;p&gt;Once comfortable with the basics, I needed to start working towards something resembling the Unicode word segmentation rules.  I had two things to work off of:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The Ragel distribution includes a script &lt;code&gt;contrib/unicode2ragel.rb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The Lucene source has &lt;a href=&#34;https://github.com/apache/lucene-solr/blob/8372b0f5a3c01dae28eeb70b6a0510a6170c57c5/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.jflex&#34;&gt;jflex rules&lt;/a&gt; for segmentation which share the same regular-expression roots&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;unicode2ragel.rb&lt;/code&gt; script would take the Unicode properties file and create ragel rules matching the corresponding utf-8 byte sequences.  Unfortunately it was hard-coded to work with a particular file, and only export particular properties.  I was able to modify this script to work off an arbitrary URL and export whichever named properties you wanted.  This let me generate Ragel rules for the properties defined in the word segmentation specification.&lt;/p&gt;

&lt;p&gt;Next, I hand converted the jflex rules in the Lucene source into the Ragel language.&lt;/p&gt;

&lt;p&gt;Finally, our existing &lt;code&gt;segment&lt;/code&gt; package had an API that we wanted to continue to support.  So I spent about another half-day attaching the right Ragel actions to the rules and massaging it to fit the API.&lt;/p&gt;

&lt;h3 id=&#34;performance:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Performance&lt;/h3&gt;

&lt;p&gt;Ragel supports 7 different code output styles, some table based, others goto based.  Benchmarking the different options showed that &lt;code&gt;-G2&lt;/code&gt; (goto, with in-place actions) yielded the highest performance.  When compared against the original for-loop version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ benchcmp before.txt after.txt 
benchmark                          old ns/op     new ns/op     delta
BenchmarkSplitWords-4              966830        457480        -52.68%
BenchmarkWordSegmenter-4           1004317       486750        -51.53%
BenchmarkWordSegmenterDirect-4     970841        463655        -52.24%

benchmark                          old allocs     new allocs     delta
BenchmarkSplitWords-4              20             20             +0.00%
BenchmarkWordSegmenter-4           36             36             +0.00%
BenchmarkWordSegmenterDirect-4     32             32             +0.00%

benchmark                          old bytes     new bytes     delta
BenchmarkSplitWords-4              380966        380971        +0.00%
BenchmarkWordSegmenter-4           496429        496432        +0.00%
BenchmarkWordSegmenterDirect-4     467706        467709        +0.00%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not too bad, the new version is 2x as fast, with no substantial change to memory usage or allocations.&lt;/p&gt;

&lt;h3 id=&#34;all-good-no:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;All good? No&amp;hellip;&lt;/h3&gt;

&lt;p&gt;Runtime performance may be the most important metric, but it&amp;rsquo;s not the only one.  One detail I neglected to mention earlier was that when I generate the code with the &lt;code&gt;-G2&lt;/code&gt; option, the resulting go file is huge:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh segment_words.go
-rw-r--r--  1 mschoch  staff   2.6M Sep  8 10:32 segment_words.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, by itself that isn&amp;rsquo;t a problem, how does it affect the size of a program using the package?  I created a test program which segments some text and compared the size of the resulting binaries.&lt;/p&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh stest
-rwxr-xr-x  1 mschoch  staff   1.3M Sep  8 13:40 stest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh stest
-rwxr-xr-x  1 mschoch  staff   6.0M Sep  8 13:41 stest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I was pleasantly surprised by this one as I thought it might be a lot worse.  I can imagine for some use cases this is a problem, but I think for most projects this will not be significant.&lt;/p&gt;

&lt;p&gt;But, there was one more thing to check with those same programs, compilation time.&lt;/p&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time go build

real	0m0.364s
user	0m0.434s
sys	0m0.079s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time go build

real	0m4.848s
user	0m6.134s
sys	0m0.523s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, that is a bit unfortunate.  The program now takes over 4.5 seconds longer to compile.  The Ragel documentation did hint that this could be a problem, and I suspect the (temporary) slowdown in the Go 1.5 tool-chain is also contributing to the problem.&lt;/p&gt;

&lt;p&gt;For projects like Bleve this is unfortunate as we had been trying to take other steps to improve compilation time, and this wipes out all of those gains.  But, in the big picture I suspect most projects would prefer the 2x runtime gain.&lt;/p&gt;

&lt;p&gt;More testing needs to be done, if one of the other output formats results in significantly faster compilation, another option would be to use build tags to control which one is used.  That way production builds get the most optimal runtime code.  But for now I&amp;rsquo;m going to let this be and see how it goes.&lt;/p&gt;

&lt;h3 id=&#34;testing-code-coverage:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Testing/Code Coverage&lt;/h3&gt;

&lt;p&gt;The Unicode specification for text segmentation also includes a suite of test strings and their correct segmentation boundaries.  We use these test cases to ensure that the behavior conforms to the specification.  I always like the fact that between that test suite and a few other well crafted strings, we were able to get the code coverage to 100%&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -coverprofile=coverage.out 
PASS
coverage: 100.0% of statements
ok  	github.com/blevesearch/segment	0.027s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, how does it look now?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -coverprofile=coverage.out 
PASS
coverage: 1.2% of statements
ok  	github.com/blevesearch/segment	0.239s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats disappointing, but not surprising.  The generated code is expanding the possible paths for efficiency, and our test set doesn&amp;rsquo;t cover nearly as many paths in the new code.&lt;/p&gt;

&lt;p&gt;Getting that number higher might be a project for another day, but I still wanted some higher confidence in this newly generated code.  And it seemed like a perfect opportunity to play with &lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;go-fuzz&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;go-fuzz:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;go-fuzz&lt;/h3&gt;

&lt;p&gt;This was my first time using go-fuzz, so I followed this &lt;a href=&#34;https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c&#34;&gt;tutorial&lt;/a&gt; by Damian Gryski.&lt;/p&gt;

&lt;p&gt;The idea was simple, I should be able to use the Unicode test suite as the initial corpus, and let go-fuzz bang away on library looking for problems.  It&amp;rsquo;s not going to help with correctness, but it can at least identify any crashes or hangs.&lt;/p&gt;

&lt;p&gt;First, I wrote a simple Fuzz function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Fuzz(data []byte) int {

	vals := make([][]byte, 0, 10000)
	types := make([]int, 0, 10000)
	if _, _, _, err := SegmentWordsDirect(data, vals, types); err != nil {
		return 0
	}
	return 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, I wrote some code to convert the test suite strings into the initial test corpus for go-fuzz.  I implemented it as a test and not a main program because the test data is only accessible from the test compilation.  You can run that with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go test -v -run=TestGenerateWordSegmentFuzz -tags gofuzz_generate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then generate the go-fuzz package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go-fuzz-build github.com/blevesearch/segment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let it run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go-fuzz -bin=segment-fuzz.zip -workdir=workdir
2015/09/08 14:19:19 slaves: 8, corpus: 1859 (0s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
2015/09/08 14:19:22 slaves: 8, corpus: 2486 (0s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 3651, uptime: 6s
2015/09/08 14:19:25 slaves: 8, corpus: 2486 (3s ago), crashers: 0, restarts: 1/6850, execs: 54804 (6068/sec), cover: 3683, uptime: 9s
... data omitted ...
2015/09/08 15:04:10 slaves: 8, corpus: 7255 (1m6s ago), crashers: 0, restarts: 1/9982, execs: 67204666 (24946/sec), cover: 20912, uptime: 44m54s
2015/09/08 15:04:13 slaves: 8, corpus: 7255 (1m9s ago), crashers: 0, restarts: 1/9985, execs: 67279017 (24945/sec), cover: 20912, uptime: 44m57s
2015/09/08 15:04:16 slaves: 8, corpus: 7265 (0s ago), crashers: 0, restarts: 1/9984, execs: 67354365 (24946/sec), cover: 20912, uptime: 45m0s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This run was for 45 minutes, I have previously let it run for several hours and it has not reported any crashers.  I was hoping this would make me feel better about things, but I still have some questions.  The documentation states that the &lt;code&gt;cover&lt;/code&gt; value is the number of bits set in a hashmap.  So more is better right?  But, the docs go on to say that the &amp;ldquo;value should be less than ~5000, otherwise fuzzer can miss new interesting inputs due to hash collisions&amp;rdquo;.  So perhaps our cover is now too high?  Maybe we&amp;rsquo;re not doing something right, so this requires more investigation.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;In summary, I&amp;rsquo;m pretty pleased with how things have turned out.  I was initially a bit intimidated by Ragel, but in just a few days I was able to use it successfully.  The runtime performance gains will be a significant boost to projects like Bleve.  The high compilation times, code coverage and fuzzing issues are things we&amp;rsquo;ll have to keep working on going forward.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re interested, please checkout the &lt;a href=&#34;https://github.com/blevesearch/segment&#34;&gt;segment&lt;/a&gt; github repo.  If you have suggestions/ideas to help us improve it further, discuss it with us on the &lt;a href=&#34;https://groups.google.com/forum/#!forum/bleve&#34;&gt;google group&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Site Search is Back!</title>
      <link>https://www.blevesearch.com/news/Site-Search/</link>
      <pubDate>Tue, 14 Jul 2015 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/news/Site-Search/</guid>
      <description>

&lt;p&gt;We recently re-launched the Bleve website using Hugo, and we temporarily lost the ability to search the site.  Today, we bring back search, and show you how you can add search to your Hugo site.&lt;/p&gt;

&lt;p&gt;At a high level, there are three steps to adding search to your site.  First, you must build the index.  Second, you must host the index.  Third, you add a search page to your site.&lt;/p&gt;

&lt;h3 id=&#34;building-the-index:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Building the Index&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Install &lt;strong&gt;hugoidx&lt;/strong&gt; - this is the command we will use build the search index.  Anytime you update your content and regenerate your site using the &lt;code&gt;hugo&lt;/code&gt; command, you&amp;rsquo;ll also want to rebuild your search index.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/blevesearch/hugoidx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cd &amp;lt;your hugo site&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;hugoidx&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You should now have a file named &lt;code&gt;search.bleve&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;hosting-the-index:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Hosting the Index&lt;/h3&gt;

&lt;p&gt;In order to host the index we need to run a small Go program that is available on the internet.  To simplify this process, we have built a reusable application called &lt;code&gt;bleve-hosted&lt;/code&gt;.  You can use this application safely answer queries to the index (read-only operations).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Install &lt;code&gt;bleve-hosted&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/blevesearch/bleve-hosted
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cd $GOPATH/src/github.com/blevesearch/bleve-hosted&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;bleve-hosted&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Test that its working:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/api/test.bleve/_search -d &#39;{&amp;quot;query&amp;quot;:{&amp;quot;query&amp;quot;:&amp;quot;bleve&amp;quot;}}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting JSON should include &amp;ldquo;total_hits&amp;rdquo;: 1&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy the &lt;code&gt;search.bleve&lt;/code&gt; index you generated earlier into your &lt;code&gt;indexes/&lt;/code&gt; folder.  (This can really be anywhere, it will always look for an &lt;code&gt;indexes/&lt;/code&gt; folder relative to the current working directly when you launch &lt;code&gt;bleve-hosted&lt;/code&gt;.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Restart &lt;code&gt;bleve-hosted&lt;/code&gt; and optionally configure your server to keep this process running long term (init-scripts, etc)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;add-search-to-your-site:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Add Search to your Site&lt;/h3&gt;

&lt;p&gt;Finally, we&amp;rsquo;re ready to add a search page to our site.  Several files were downloaded as a part of the &lt;code&gt;hugoidx&lt;/code&gt; package to help you get started.  Feel free to customize these files to best adapt them to your site.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cd &amp;lt;your hugo site&amp;gt;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy the main search page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp $GOPATH/src/github.com/blevesearch/hugoidx/search.md content/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy support JavaScript files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p static/js/
cp $GOPATH/src/github.com/blevesearch/hugoidx/handlebars.js static/js/
cp $GOPATH/src/github.com/blevesearch/hugoidx/search.js static/js/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handlebars.js is used to render search results using a simple template syntax.&lt;br /&gt;
search.js is our custom code to bind everything together.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If your site is not already using jQuery:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp $GOPATH/src/github.com/blevesearch/hugoidx/jquery.min.js static/js/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery is used to make AJAX requests from the browser to &lt;code&gt;bleve-hosted&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update your layout to include these javascript files.  For many sites this will be in a file like &lt;code&gt;layouts/partial/footer.html&lt;/code&gt; or &lt;code&gt;themes/&amp;lt;your theme&amp;gt;/layouts/partials/footer.html&lt;/code&gt;.  In the section where javascript files are being included you&amp;rsquo;ll want to add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;/js/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;/js/handlebars.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;/js/search.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, we need to update search.js to point to the correct URL for &lt;code&gt;bleve-hosted&lt;/code&gt;.  On line 2 of &lt;code&gt;static/js/search.js&lt;/code&gt; modify the value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var searchURL = &#39;http://&amp;lt;your server&amp;gt;:8080/api/search.bleve/_search&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;try-it-out:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Try it Out&lt;/h3&gt;

&lt;p&gt;Now, you&amp;rsquo;re ready to regenerate your site and try it out.  If you open your browser to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://localhost:1313/search
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see the standard search box.  If you type in your query, the page should reload and display search results below.  If you run into problems, it may be helpful to view the javascript console.&lt;/p&gt;

&lt;h3 id=&#34;finishing-touches:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Finishing Touches&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s also add search to the navigation bar.  For our site, we modified the partial &lt;code&gt;navbar.html&lt;/code&gt; to include the following inside the navigation unordered-list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;div class=&amp;quot;dropdown pull-right&amp;quot;&amp;gt;
      &amp;lt;form class=&amp;quot;navbar-form&amp;quot; role=&amp;quot;search&amp;quot; action=&amp;quot;/search&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;input-group&amp;quot;&amp;gt;
            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;Search&amp;quot; name=&amp;quot;q&amp;quot; id=&amp;quot;srch-term&amp;quot;&amp;gt;
            &amp;lt;div class=&amp;quot;input-group-btn&amp;quot;&amp;gt;
                &amp;lt;button class=&amp;quot;btn btn-default&amp;quot; type=&amp;quot;submit&amp;quot;&amp;gt;&amp;lt;i class=&amp;quot;glyphicon glyphicon-search&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;future:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Future&lt;/h3&gt;

&lt;p&gt;Is this perfect? No, not really, there are a still a lot of rough edges we&amp;rsquo;d like to smooth out.  Here are some of our ideas for the future:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Enable running &lt;code&gt;bleve-hosted&lt;/code&gt; in Google App Engine.  This lowers the bar for hosting your index.&lt;/li&gt;
&lt;li&gt;Streamline the addition of search to your site.  The manual copying of multiple files and editing paths is error prone.  Perhaps additional sub-commands of &lt;code&gt;hugoidx&lt;/code&gt; could assist with this.&lt;/li&gt;
&lt;li&gt;Document worklfow for keeping your site AND your search index up to date.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Having problems with these instructions?  Let us know via &lt;a href=&#34;mailto:info@blevesearch.com&#34;&gt;email&lt;/a&gt; or the &lt;a href=&#34;https://groups.google.com/forum/#!forum/bleve&#34;&gt;Google Group&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GopherCon Lightning Talk</title>
      <link>https://www.blevesearch.com/events/gopherCon2015/</link>
      <pubDate>Fri, 10 Jul 2015 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/events/gopherCon2015/</guid>
      <description>&lt;p&gt;The GopherCon lightning talk was a success!  It was great to meet so many Bleve users at GopherCon.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/blevesearch/gophercon15/blob/master/bleve-gophercon15.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/9nSA5L8lO0A&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Site Migrated to Hugo</title>
      <link>https://www.blevesearch.com/news/Site-Migrated-to-Hugo/</link>
      <pubDate>Thu, 02 Jul 2015 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/news/Site-Migrated-to-Hugo/</guid>
      <description>

&lt;p&gt;You may notice the site looks a little different today.  We&amp;rsquo;ve just launched a version of the site built with &lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;.  The site is functional, but still also very much a work in progress.  Don&amp;rsquo;t hesitate to report any problems you find.&lt;/p&gt;

&lt;h3 id=&#34;why-did-we-make-the-change:871bbe6ca1368764a58ff754bed0e978&#34;&gt;Why did we make the change?&lt;/h3&gt;

&lt;p&gt;Our initial site was just a set of 3 static HTML files.  With so few files, it was reasonable to just copy/paste the headers/footers, etc.  But Bleve is growing, and as we continue to progress our site needs more pages.  Moving beyond just a few pages requires us to use some automation.  I&amp;rsquo;ve used Hugo to build small sites in the past and it&amp;rsquo;s worked great.  And we&amp;rsquo;re happy to support another Go project.&lt;/p&gt;

&lt;h3 id=&#34;site-changes:871bbe6ca1368764a58ff754bed0e978&#34;&gt;Site Changes&lt;/h3&gt;

&lt;p&gt;For the most part you&amp;rsquo;ll find the current site looks similar to the previous site.  The biggest change is that we&amp;rsquo;ve moved our documentation from the Github Wiki into the website itself.  Initially we liked the idea of using the wiki for documentation, particularly because it has such a low bar for users to contribute content.  But, with very little contribution actually happening, we feel there will be more benefits to bringing it into the website.&lt;/p&gt;

&lt;h3 id=&#34;what-about-search:871bbe6ca1368764a58ff754bed0e978&#34;&gt;What about Search?&lt;/h3&gt;

&lt;p&gt;Previously we offered an integrated github wiki search on the website, and as of today that is now missing.  However, stay tuned for future announcements!  Bleve site and documentation search will be back.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Videos</title>
      <link>https://www.blevesearch.com/videos/</link>
      <pubDate>Thu, 25 Jun 2015 12:25:45 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/videos/</guid>
      <description>

&lt;h3 id=&#34;fosdem-2015:a45b24697a235d080c581c0ce5a9b90b&#34;&gt;FOSDEM 2015&lt;/h3&gt;

&lt;p&gt;An introduction to the Bleve project given at the Go Devroom at FOSDEM 2015.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/Vhc_1Ta3Mi0&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h3 id=&#34;gophercon-india-2015:a45b24697a235d080c581c0ce5a9b90b&#34;&gt;GopherCon India 2015&lt;/h3&gt;

&lt;p&gt;An introduction to the Bleve project given at GopherCon India in Bengaluru.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/uEhs_xrWJNw&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h3 id=&#34;bleve-analysis-wizard:a45b24697a235d080c581c0ce5a9b90b&#34;&gt;Bleve Analysis Wizard&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;http://analysis.blevesearch.com/&#34;&gt;Bleve Text Analysis Wizard&lt;/a&gt; is a tool to help users experiment with the effects different analyzers have on their text.  Below is a short video showing how the tool works.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/CEfaIlzki5U&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h3 id=&#34;bleve-explorer:a45b24697a235d080c581c0ce5a9b90b&#34;&gt;Bleve Explorer&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/blevesearch/bleve-explorer&#34;&gt;Bleve Explorer&lt;/a&gt; is an example application to show how to integrate bleve with an HTTP/REST/JSON interface.  Below is a short video showing how the application works.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/DfbRTXE5n4Y&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>