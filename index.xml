<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bleve</title>
    <link>http://www.blevesearch.com/</link>
    <description>Recent content on Bleve</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© &lt;a href=&#34;http://couchbase.com/&#34;&gt;Couchbase&lt;/a&gt; 2015</copyright>
    <lastBuildDate>Mon, 09 Nov 2015 10:25:38 -0400</lastBuildDate>
    <atom:link href="http://www.blevesearch.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>dotGo</title>
      <link>http://www.blevesearch.com/events/dotGo2015/</link>
      <pubDate>Mon, 09 Nov 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/events/dotGo2015/</guid>
      <description>&lt;p&gt;We&amp;rsquo;re back!  I tried something a little bit different in this talk, I explored the unique way that contributors have shaped the project.  The dotGo conference delivered a day full of great talks, I encourage you to &lt;a href=&#34;http://www.thedotpost.com/conference/dotgo-2015&#34;&gt;check out all of them&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Discussion @ &lt;a href=&#34;http://www.thedotpost.com/2015/11/marty-schoch-a-tour-of-the-bleve&#34;&gt;The dot Post&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Video:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/OynPw4aOlV0&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Slides:&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;5deddf2a4c67446e9d8526cc19fe6e13&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Index Structure</title>
      <link>http://www.blevesearch.com/docs/Index-Structure/</link>
      <pubDate>Fri, 09 Oct 2015 00:00:00 +0100</pubDate>
      
      <guid>http://www.blevesearch.com/docs/Index-Structure/</guid>
      <description>

&lt;p&gt;Bleve default index, called &amp;ldquo;upside_down&amp;rdquo; is stored in a single key/value store
table. The store must be able to enumerate its entries starting at a given key,
in lexicographic byte order.&lt;/p&gt;

&lt;p&gt;Index key and values are handled as byte arrays and are called rows (see &lt;code&gt;index/upside_down/row.go&lt;/code&gt; for details). To store different row types in a single table, bleve prefixes their keys with a single byte, for instance the term frequency keys start with a &amp;rsquo;t&amp;rsquo;. The following sections describe the data structures stored in the index with pseudo-Go code for value layout.&lt;/p&gt;

&lt;h3 id=&#34;version-row:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Version Row&lt;/h3&gt;

&lt;p&gt;Key: &lt;code&gt;&amp;quot;v&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
	Version uint8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only one version row exists in the index and is used to check version compatibility&lt;/p&gt;

&lt;h3 id=&#34;field-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Field Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;f&amp;quot;&lt;/code&gt;, &lt;code&gt;fieldIndex&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
	Name string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They map field qualified names to internal integer indices. The field names are only used or displayed at API level, bleve uses the indices everywhere internally.&lt;/p&gt;

&lt;h3 id=&#34;dictionary-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Dictionary Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;d&amp;quot;&lt;/code&gt;, &lt;code&gt;fieldIndex&lt;/code&gt;, &lt;code&gt;term&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
	Count uint64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dictionary rows index (field, term) pairs and count the number of documents containing them. Range queries over terms of a given field, which includes prefix queries, are implemented by seeking over dictionary rows first.&lt;/p&gt;

&lt;h3 id=&#34;term-frequency-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Term Frequency Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;t&amp;quot;&lt;/code&gt;, &lt;code&gt;fieldIndex&lt;/code&gt;, &lt;code&gt;term&lt;/code&gt;, &lt;code&gt;docId&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type TermFrequencyRow struct {
	Freq    uint64
	Norm    float32
	Vectors []struct{
		Field          uint16
		ArrayPositions []uint64
		Pos            uint64
		Start          uint64
		End            uint64
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Term frequency rows store statistics about a term in a document field. Applications using result highlighting or phrase search must also record term locations by setting &lt;code&gt;IncludeTermVectors&lt;/code&gt; in the field mapping. Term locations are used to retrieve the term origin in the source document or measure terms proximity.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Freq&lt;/code&gt; is the number of occurrences of the term in the field.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Norm&lt;/code&gt; is 1/sqrt(number of tokens in the field). This factor helps balancing scores of shorter documents which have lower term frequencies.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vectors&lt;/code&gt; is filled if &lt;code&gt;IncludeTermVectors&lt;/code&gt; is set in the field mapping. Each element describes a single occurrence of the term in the source document. &lt;code&gt;Field&lt;/code&gt; is the field index, and is the same as in the row key except for composite fields where it references the source field (composite fields like &lt;code&gt;_all&lt;/code&gt; are made of the union of other fields). Because documents are structured as trees and intermediate elements can be arrays or slices, the field index is sometimes not enough to resolve a value. The indices of the value or some of its ancestors into those arrays or slices are also required. They are stored in &lt;code&gt;ArrayPositions&lt;/code&gt;. &lt;code&gt;Pos&lt;/code&gt; tells the entry is the &lt;code&gt;Pos&lt;/code&gt;-th occurrence of the term in the field (starting at 1). &lt;code&gt;Start&lt;/code&gt; and &lt;code&gt;End&lt;/code&gt; are the byte offsets of the source of the term in the field value.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;back-index-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Back Index Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt;, &lt;code&gt;docId&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
    Indexed []struct{
		Term []byte
		Field uint32
	},
	Stored []struct{
		Field uint32
		ArrayPositions []uint64
	},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Back index rows describe the indexed and stored terms of a document. &lt;code&gt;Field&lt;/code&gt; is the field index and &lt;code&gt;ArrayPositions&lt;/code&gt; is explained in Term frequency rows section.&lt;/p&gt;

&lt;h3 id=&#34;stored-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Stored Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;s&amp;quot;&lt;/code&gt;, &lt;code&gt;docId&lt;/code&gt;, &lt;code&gt;fieldId&lt;/code&gt;, &lt;code&gt;arrayPositions&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
	Value []byte
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Stored rows contains the values of document fields which mapping had the &lt;code&gt;Store&lt;/code&gt; property. &lt;code&gt;arrayPositions&lt;/code&gt; meaning is described in Term frequency rows section.&lt;/p&gt;

&lt;h3 id=&#34;internal-rows:c0e4a9c5fa2f1af4fb6097ff3abb8877&#34;&gt;Internal Rows&lt;/h3&gt;

&lt;p&gt;Key: (&lt;code&gt;&amp;quot;i&amp;quot;&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
    Value []byte
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Internal rows are used to store arbitrary data in the index.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deferred Cleanup, Checking Errors, and Potential Problems</title>
      <link>http://www.blevesearch.com/news/Deferred-Cleanup,-Checking-Errors,-and-Potential-Problems/</link>
      <pubDate>Mon, 28 Sep 2015 10:40:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/news/Deferred-Cleanup,-Checking-Errors,-and-Potential-Problems/</guid>
      <description>

&lt;p&gt;The &lt;em&gt;defer&lt;/em&gt; statement in Go is frequently used to ensure that once a resource has been acquired, it will be properly cleaned up.  In its simplest form it works exactly as you expect.  But, as you move to more advanced usages there are some things to watch out for.  I&amp;rsquo;d like to share one that I recently ran into while writing Bleve test cases.&lt;/p&gt;

&lt;h3 id=&#34;basics:ffe76477ce26feb5927595f82ec07acf&#34;&gt;Basics&lt;/h3&gt;

&lt;p&gt;The power of the &lt;em&gt;defer&lt;/em&gt; statement in Go is that it lets you put the acquisition and cleanup of a resource side by side.  When you read code later, it&amp;rsquo;s easy to see that the correct behavior is guaranteed.  Let&amp;rsquo;s take a look at a simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer r.Close()
}

type Resource struct {
	name string
}

func Open(name string) (*Resource, error) {
	return &amp;amp;Resource{name}, nil
}

func (r *Resource) Close() error {
	log.Printf(&amp;quot;closing %s\n&amp;quot;, r.name)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/fYB2alVcIw&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The main function shows some very common behavior.  Open a resource, check for an error, then &lt;em&gt;defer&lt;/em&gt; Closing the resource.  When we run this, we get the expected behavior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing a
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;opening-another-resource-reusing-the-variable:ffe76477ce26feb5927595f82ec07acf&#34;&gt;Opening another Resource, Reusing the Variable&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s make the example a bit more complex.  Now, after closing the resource, we will open another one (with a different name).  Can we reuse the same variable?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer r.Close()

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer r.Close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/Bal_y0nv4U&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When I was new to Go and first encountered this code I wasn&amp;rsquo;t sure if this would work.  I knew that &lt;em&gt;defer&lt;/em&gt; would not execute until the end of main, but would it close &amp;lsquo;a&amp;rsquo; AND &amp;lsquo;b&amp;rsquo;?  Or would it close &amp;lsquo;b&amp;rsquo; twice?  If we run it we see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing b
2009/11/10 23:00:00 closing a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, it does work, this is the expected output.  Some of you may be wondering, but &lt;em&gt;why&lt;/em&gt; does it work?  As the Go blog &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34;&gt;Defer, Panic, and Recover&lt;/a&gt; explains,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A deferred function&amp;rsquo;s arguments are evaluated when the defer statement is evaluated.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In our case, the method receiver &amp;lsquo;r&amp;rsquo; for the Close() method behaves just like an argument.  So the &amp;lsquo;r&amp;rsquo; is evaluated at the time the defer statement is evaluated, and &lt;em&gt;NOT&lt;/em&gt; when the statement is executed.  In Bleve code we saw this pattern occur frequently in test cases.  We would acquire a resource, take some action, close the resource, check the state of things, then repeat the process.&lt;/p&gt;

&lt;h3 id=&#34;errcheck:ffe76477ce26feb5927595f82ec07acf&#34;&gt;errcheck?&lt;/h3&gt;

&lt;p&gt;Last February I had the amazing opportunity to attend &lt;a href=&#34;http://www.gophercon.in/&#34;&gt;GopherCon India&lt;/a&gt;.  One of the many things I learned while there was of a tool called &lt;a href=&#34;https://github.com/kisielk/errcheck&#34;&gt;errcheck&lt;/a&gt;.  The idea of the tool is simple, it looks at your Go code and identifies places where you&amp;rsquo;re not checking a returned error.  This seemed like such an obvious thing to do, so I ran it on the entire Bleve codebase.  We found several clear cases where an error was returned, and we would not propagate the error back to the caller.&lt;/p&gt;

&lt;p&gt;But what happens if we run &lt;em&gt;errcheck&lt;/em&gt; on the code we just wrote above?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github.com/mschoch/defertest/main.go:10:15	defer r.Close()
github.com/mschoch/defertest/main.go:16:15	defer r.Close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Close() method returns an error.  Although it&amp;rsquo;s not used in this contrived example, I coded it that way on purpose as that is very common in the real world.  Does checking this error matter?  If closing the first resource results in an error, should you try to close the second one?  In the abstract these are interesting philosophical questions, but let&amp;rsquo;s assume we do want to check the errors.  How would we do it?  My first attempt looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer func() {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer func() {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/_MPUl6zWjF&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I added an anonymous function which invokes r.Close(), checks the error, and if its non-nil we exit the program through log.Fatal().  It seems like such a simple change, but we&amp;rsquo;ve introduced a severe bug into the code.  In our case we can see it clearly since we&amp;rsquo;re printing out the name of the resource being closed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing b
2009/11/10 23:00:00 closing b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oops!  We&amp;rsquo;re now closing the &amp;lsquo;b&amp;rsquo; resource twice, and never closing the &amp;lsquo;a&amp;rsquo; resource.  This is a severe problem, closing &amp;lsquo;b&amp;rsquo; a second time may not be well defined behavior, and not closing &amp;lsquo;a&amp;rsquo; may leak resources.&lt;/p&gt;

&lt;p&gt;Where did we go wrong?  Remember the rule we were given was:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A deferred function&amp;rsquo;s arguments are evaluated when the defer statement is evaluated.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And in our new code, the deferred function has no arguments, and no method receiver.  We&amp;rsquo;re now relying the anonymous function referring to &amp;lsquo;r&amp;rsquo;.  The Go spec says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;rdquo;&amp;hellip;they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, now it&amp;rsquo;s fairly clear what happened.  At the time the &lt;em&gt;defer&lt;/em&gt; statement was evaluated, the arguments were evaluated, but there were none.  Then at the end of the function, the deferred function is executed, and &lt;em&gt;now&lt;/em&gt; as the anonymous functions are executed, &amp;lsquo;r&amp;rsquo; is evaluated, and in both cases it refers to &amp;lsquo;b&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;the-fix:ffe76477ce26feb5927595f82ec07acf&#34;&gt;The Fix&lt;/h3&gt;

&lt;p&gt;Option 1, we can rewrite the &lt;em&gt;defer&lt;/em&gt; statement to pass &amp;lsquo;r&amp;rsquo; as an argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer func(r *Resource) {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}(r)

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer func(r *Resource) {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}(r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This does give the correct output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing b
2009/11/10 23:00:00 closing a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But, to be honest, it&amp;rsquo;s rather verbose.  In many cases it may just be simpler to use a different variable name.  Option 2, use a new variable for the second resource:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer func() {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()

	r2, err := Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer func() {
		err := r2.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;UPDATE: 2015-09-29&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Users &lt;a href=&#34;https://www.reddit.com/r/golang/comments/3mqxar/deferred_cleanup_checking_errors_and_potential/&#34;&gt;discussing this on Reddit&lt;/a&gt; proposed a third option.  Create a named cleanup function and use the existing io.Closer interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer Close(r)

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer Close(r)
}

func Close(c io.Closer) {
	err := c.Close()
	if err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/ZjlavK1r6N&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As I mentioned earlier, in Bleve this pattern only seems to arise in test cases.  I suspect in real code you&amp;rsquo;d be more likely to already be using more descriptive identifiers.&lt;/p&gt;

&lt;h3 id=&#34;summary:ffe76477ce26feb5927595f82ec07acf&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;To me the lesson here is that we had a simple pattern for deferred cleanup that worked.  I even explicitly took the time to verify that it cleaned up the correct resources when I reused variables.  Then I took the seemingly natural step to make sure we check all the returned errors.  But, I was a bit careless and overlooked that the deferred anonymous function can have significantly different behavior.  It wasn&amp;rsquo;t until I observed problems that I went back to recheck my assumptions and track down the problem.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Faster Tokenization with Ragel generated FSM</title>
      <link>http://www.blevesearch.com/news/Faster-Tokenization-with-Ragel-generated-FSM/</link>
      <pubDate>Tue, 08 Sep 2015 10:40:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/news/Faster-Tokenization-with-Ragel-generated-FSM/</guid>
      <description>

&lt;p&gt;Text processed by Bleve must first go through the process of tokenization.  Read on to learn how we sped up the process by a factor of 2x by introducing an FSM generated by &lt;a href=&#34;https://www.colm.net/open-source/ragel/&#34;&gt;Ragel&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tokenization:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Tokenization?&lt;/h3&gt;

&lt;p&gt;Tokenization is the process by which we take a string like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;Using Ragel to tokenize 2.1x faster.&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And turn it into discrete tokens:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;Using&amp;quot;, &amp;quot;Ragel&amp;quot;, &amp;quot;to&amp;quot;, &amp;quot;tokenize&amp;quot;, &amp;quot;2.1x&amp;quot;, &amp;quot;faster&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Your first thought might be that we can simply split the text up using the Unicode White Space property.  And for simple use cases that might be good enough, but you still have to handle removing punctuation.  Unicode defines properties for that as well, but if we want to retain &lt;code&gt;2.1x&lt;/code&gt; as is, we can&amp;rsquo;t simply remove all punctuation.  Fortunately, the Unicode specification has already addressed this problem and defined rules for word segmentation.&lt;/p&gt;

&lt;h3 id=&#34;unicode-text-segmentation:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Unicode Text Segmentation&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;re interested in all details, see &lt;a href=&#34;http://unicode.org/reports/tr29/&#34;&gt;UnicodeÂ® Standard Annex #29&lt;/a&gt;.  What matters for this discussion is that it defines a set of rules, based on which characters occur before and after others, to decide whether or not to break up the text.&lt;/p&gt;

&lt;p&gt;Our first solution was simply to integrate with the C library &lt;a href=&#34;http://site.icu-project.org/&#34;&gt;ICU&lt;/a&gt;.  This got us up and running quickly, but having a dependency on ICU was not a long term solution.&lt;/p&gt;

&lt;p&gt;Next, I set out to write my own implementation.  I followed the lead I found in the Go standard library&amp;rsquo;s &lt;a href=&#34;https://github.com/golang/go/tree/master/src/unicode&#34;&gt;unicode package&lt;/a&gt;, and wrote code which generated &lt;code&gt;unicode.RangeTable&lt;/code&gt;s for all the properties defined by the word segmentation rules.  Next, I wrote a for loop which walked through the slice of bytes, kept track of which types of characters occurred in sequence, and returned the segmented text at the appropriate places.  Fortunately, the Unicode specification also includes test cases, so after banging on the code for a while I had something that worked.&lt;/p&gt;

&lt;p&gt;While it was great that it was working, it had some serious drawbacks.  First, if the rules evolve in a newer Unicode spec, updating this code base could be tricky.  Second, while it performed good enough to use, I always knew that the for-loops and Unicode range table lookups were not optimal.&lt;/p&gt;

&lt;h3 id=&#34;a-generated-fsm-solution:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;A Generated FSM Solution&lt;/h3&gt;

&lt;p&gt;The appeal of a generated FSM solution was that we could keep the rule definitions at a high level.  This lets us easily modify them as they change, and it also allows for the possibility of customization in the future.  Second, the generated code should be able to take advantage of well understood FSM techniques and perform faster than my hand-rolled for-loop.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve gone looking for FSM solutions in the Go ecosystem in the past and never found one that seemed to meet my needs.  This time however, I came across someone suggesting &lt;a href=&#34;https://www.colm.net/open-source/ragel/&#34;&gt;Ragel&lt;/a&gt;.  To be honest, approaching a project like this can be daunting.  Just looking at the example on their home page you realize you have to learn their DSL.  Sure it&amp;rsquo;s rooted in regular-expressions, but the full syntax goes beyond that.  The documentation looked solid, but I still wondered, how good is Go code generator?  The code isn&amp;rsquo;t on github and there doesn&amp;rsquo;t appear to be any community around it. Am I going to invest a day learning this just to hit some dead end?&lt;/p&gt;

&lt;p&gt;I was desperate, so I dove in despite my concerns&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;ragel:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Ragel&lt;/h3&gt;

&lt;p&gt;I started by trying to write a test program, just to get comfortable writing rules in Ragel and generating Go code.  I came across this project &lt;a href=&#34;https://github.com/acsellers/ragel-go-examples&#34;&gt;ragel-go-examples&lt;/a&gt;, which I recommend to anyone else getting started.&lt;/p&gt;

&lt;p&gt;Once comfortable with the basics, I needed to start working towards something resembling the Unicode word segmentation rules.  I had two things to work off of:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The Ragel distribution includes a script &lt;code&gt;contrib/unicode2ragel.rb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The Lucene source has &lt;a href=&#34;https://github.com/apache/lucene-solr/blob/8372b0f5a3c01dae28eeb70b6a0510a6170c57c5/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.jflex&#34;&gt;jflex rules&lt;/a&gt; for segmentation which share the same regular-expression roots&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;unicode2ragel.rb&lt;/code&gt; script would take the Unicode properties file and create ragel rules matching the corresponding utf-8 byte sequences.  Unfortunately it was hard-coded to work with a particular file, and only export particular properties.  I was able to modify this script to work off an arbitrary URL and export whichever named properties you wanted.  This let me generate Ragel rules for the properties defined in the word segmentation specification.&lt;/p&gt;

&lt;p&gt;Next, I hand converted the jflex rules in the Lucene source into the Ragel language.&lt;/p&gt;

&lt;p&gt;Finally, our existing &lt;code&gt;segment&lt;/code&gt; package had an API that we wanted to continue to support.  So I spent about another half-day attaching the right Ragel actions to the rules and massaging it to fit the API.&lt;/p&gt;

&lt;h3 id=&#34;performance:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Performance&lt;/h3&gt;

&lt;p&gt;Ragel supports 7 different code output styles, some table based, others goto based.  Benchmarking the different options showed that &lt;code&gt;-G2&lt;/code&gt; (goto, with in-place actions) yielded the highest performance.  When compared against the original for-loop version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ benchcmp before.txt after.txt 
benchmark                          old ns/op     new ns/op     delta
BenchmarkSplitWords-4              966830        457480        -52.68%
BenchmarkWordSegmenter-4           1004317       486750        -51.53%
BenchmarkWordSegmenterDirect-4     970841        463655        -52.24%

benchmark                          old allocs     new allocs     delta
BenchmarkSplitWords-4              20             20             +0.00%
BenchmarkWordSegmenter-4           36             36             +0.00%
BenchmarkWordSegmenterDirect-4     32             32             +0.00%

benchmark                          old bytes     new bytes     delta
BenchmarkSplitWords-4              380966        380971        +0.00%
BenchmarkWordSegmenter-4           496429        496432        +0.00%
BenchmarkWordSegmenterDirect-4     467706        467709        +0.00%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not too bad, the new version is 2x as fast, with no substantial change to memory usage or allocations.&lt;/p&gt;

&lt;h3 id=&#34;all-good-no:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;All good? No&amp;hellip;&lt;/h3&gt;

&lt;p&gt;Runtime performance may be the most important metric, but it&amp;rsquo;s not the only one.  One detail I neglected to mention earlier was that when I generate the code with the &lt;code&gt;-G2&lt;/code&gt; option, the resulting go file is huge:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh segment_words.go
-rw-r--r--  1 mschoch  staff   2.6M Sep  8 10:32 segment_words.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, by itself that isn&amp;rsquo;t a problem, how does it affect the size of a program using the package?  I created a test program which segments some text and compared the size of the resulting binaries.&lt;/p&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh stest
-rwxr-xr-x  1 mschoch  staff   1.3M Sep  8 13:40 stest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh stest
-rwxr-xr-x  1 mschoch  staff   6.0M Sep  8 13:41 stest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I was pleasantly surprised by this one as I thought it might be a lot worse.  I can imagine for some use cases this is a problem, but I think for most projects this will not be significant.&lt;/p&gt;

&lt;p&gt;But, there was one more thing to check with those same programs, compilation time.&lt;/p&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time go build

real	0m0.364s
user	0m0.434s
sys	0m0.079s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time go build

real	0m4.848s
user	0m6.134s
sys	0m0.523s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, that is a bit unfortunate.  The program now takes over 4.5 seconds longer to compile.  The Ragel documentation did hint that this could be a problem, and I suspect the (temporary) slowdown in the Go 1.5 tool-chain is also contributing to the problem.&lt;/p&gt;

&lt;p&gt;For projects like Bleve this is unfortunate as we had been trying to take other steps to improve compilation time, and this wipes out all of those gains.  But, in the big picture I suspect most projects would prefer the 2x runtime gain.&lt;/p&gt;

&lt;p&gt;More testing needs to be done, if one of the other output formats results in significantly faster compilation, another option would be to use build tags to control which one is used.  That way production builds get the most optimal runtime code.  But for now I&amp;rsquo;m going to let this be and see how it goes.&lt;/p&gt;

&lt;h3 id=&#34;testing-code-coverage:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Testing/Code Coverage&lt;/h3&gt;

&lt;p&gt;The Unicode specification for text segmentation also includes a suite of test strings and their correct segmentation boundaries.  We use these test cases to ensure that the behavior conforms to the specification.  I always like the fact that between that test suite and a few other well crafted strings, we were able to get the code coverage to 100%&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -coverprofile=coverage.out 
PASS
coverage: 100.0% of statements
ok  	github.com/blevesearch/segment	0.027s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, how does it look now?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -coverprofile=coverage.out 
PASS
coverage: 1.2% of statements
ok  	github.com/blevesearch/segment	0.239s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats disappointing, but not surprising.  The generated code is expanding the possible paths for efficiency, and our test set doesn&amp;rsquo;t cover nearly as many paths in the new code.&lt;/p&gt;

&lt;p&gt;Getting that number higher might be a project for another day, but I still wanted some higher confidence in this newly generated code.  And it seemed like a perfect opportunity to play with &lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;go-fuzz&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;go-fuzz:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;go-fuzz&lt;/h3&gt;

&lt;p&gt;This was my first time using go-fuzz, so I followed this &lt;a href=&#34;https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c&#34;&gt;tutorial&lt;/a&gt; by Damian Gryski.&lt;/p&gt;

&lt;p&gt;The idea was simple, I should be able to use the Unicode test suite as the initial corpus, and let go-fuzz bang away on library looking for problems.  It&amp;rsquo;s not going to help with correctness, but it can at least identify any crashes or hangs.&lt;/p&gt;

&lt;p&gt;First, I wrote a simple Fuzz function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Fuzz(data []byte) int {

	vals := make([][]byte, 0, 10000)
	types := make([]int, 0, 10000)
	if _, _, _, err := SegmentWordsDirect(data, vals, types); err != nil {
		return 0
	}
	return 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, I wrote some code to convert the test suite strings into the initial test corpus for go-fuzz.  I implemented it as a test and not a main program because the test data is only accessible from the test compilation.  You can run that with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go test -v -run=TestGenerateWordSegmentFuzz -tags gofuzz_generate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then generate the go-fuzz package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go-fuzz-build github.com/blevesearch/segment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let it run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go-fuzz -bin=segment-fuzz.zip -workdir=workdir
2015/09/08 14:19:19 slaves: 8, corpus: 1859 (0s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
2015/09/08 14:19:22 slaves: 8, corpus: 2486 (0s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 3651, uptime: 6s
2015/09/08 14:19:25 slaves: 8, corpus: 2486 (3s ago), crashers: 0, restarts: 1/6850, execs: 54804 (6068/sec), cover: 3683, uptime: 9s
... data omitted ...
2015/09/08 15:04:10 slaves: 8, corpus: 7255 (1m6s ago), crashers: 0, restarts: 1/9982, execs: 67204666 (24946/sec), cover: 20912, uptime: 44m54s
2015/09/08 15:04:13 slaves: 8, corpus: 7255 (1m9s ago), crashers: 0, restarts: 1/9985, execs: 67279017 (24945/sec), cover: 20912, uptime: 44m57s
2015/09/08 15:04:16 slaves: 8, corpus: 7265 (0s ago), crashers: 0, restarts: 1/9984, execs: 67354365 (24946/sec), cover: 20912, uptime: 45m0s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This run was for 45 minutes, I have previously let it run for several hours and it has not reported any crashers.  I was hoping this would make me feel better about things, but I still have some questions.  The documentation states that the &lt;code&gt;cover&lt;/code&gt; value is the number of bits set in a hashmap.  So more is better right?  But, the docs go on to say that the &amp;ldquo;value should be less than ~5000, otherwise fuzzer can miss new interesting inputs due to hash collisions&amp;rdquo;.  So perhaps our cover is now too high?  Maybe we&amp;rsquo;re not doing something right, so this requires more investigation.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;In summary, I&amp;rsquo;m pretty pleased with how things have turned out.  I was initially a bit intimidated by Ragel, but in just a few days I was able to use it successfully.  The runtime performance gains will be a significant boost to projects like Bleve.  The high compilation times, code coverage and fuzzing issues are things we&amp;rsquo;ll have to keep working on going forward.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re interested, please checkout the &lt;a href=&#34;https://github.com/blevesearch/segment&#34;&gt;segment&lt;/a&gt; github repo.  If you have suggestions/ideas to help us improve it further, discuss it with us on the &lt;a href=&#34;https://groups.google.com/forum/#!forum/bleve&#34;&gt;google group&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Site Search is Back!</title>
      <link>http://www.blevesearch.com/news/Site-Search/</link>
      <pubDate>Tue, 14 Jul 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/news/Site-Search/</guid>
      <description>

&lt;p&gt;We recently re-launched the Bleve website using Hugo, and we temporarily lost the ability to search the site.  Today, we bring back search, and show you how you can add search to your Hugo site.&lt;/p&gt;

&lt;p&gt;At a high level, there are three steps to adding search to your site.  First, you must build the index.  Second, you must host the index.  Third, you add a search page to your site.&lt;/p&gt;

&lt;h3 id=&#34;building-the-index:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Building the Index&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Install &lt;strong&gt;hugoidx&lt;/strong&gt; - this is the command we will use build the search index.  Anytime you update your content and regenerate your site using the &lt;code&gt;hugo&lt;/code&gt; command, you&amp;rsquo;ll also want to rebuild your search index.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/blevesearch/hugoidx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cd &amp;lt;your hugo site&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;hugoidx&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You should now have a file named &lt;code&gt;search.bleve&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;hosting-the-index:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Hosting the Index&lt;/h3&gt;

&lt;p&gt;In order to host the index we need to run a small Go program that is available on the internet.  To simplify this process, we have built a reusable application called &lt;code&gt;bleve-hosted&lt;/code&gt;.  You can use this application safely answer queries to the index (read-only operations).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Install &lt;code&gt;bleve-hosted&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/blevesearch/bleve-hosted
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cd $GOPATH/src/github.com/blevesearch/bleve-hosted&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;bleve-hosted&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Test that its working:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/api/test.bleve/_search -d &#39;{&amp;quot;query&amp;quot;:{&amp;quot;query&amp;quot;:&amp;quot;bleve&amp;quot;}}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting JSON should include &amp;ldquo;total_hits&amp;rdquo;: 1&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy the &lt;code&gt;search.bleve&lt;/code&gt; index you generated earlier into your &lt;code&gt;indexes/&lt;/code&gt; folder.  (This can really be anywhere, it will always look for an &lt;code&gt;indexes/&lt;/code&gt; folder relative to the current working directly when you launch &lt;code&gt;bleve-hosted&lt;/code&gt;.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Restart &lt;code&gt;bleve-hosted&lt;/code&gt; and optionally configure your server to keep this process running long term (init-scripts, etc)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;add-search-to-your-site:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Add Search to your Site&lt;/h3&gt;

&lt;p&gt;Finally, we&amp;rsquo;re ready to add a search page to our site.  Several files were downloaded as a part of the &lt;code&gt;hugoidx&lt;/code&gt; package to help you get started.  Feel free to customize these files to best adapt them to your site.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cd &amp;lt;your hugo site&amp;gt;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy the main search page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp $GOPATH/src/github.com/blevesearch/hugoidx/search.md content/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy support JavaScript files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p static/js/
cp $GOPATH/src/github.com/blevesearch/hugoidx/handlebars.js static/js/
cp $GOPATH/src/github.com/blevesearch/hugoidx/search.js static/js/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handlebars.js is used to render search results using a simple template syntax.&lt;br /&gt;
search.js is our custom code to bind everything together.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If your site is not already using jQuery:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp $GOPATH/src/github.com/blevesearch/hugoidx/jquery.min.js static/js/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery is used to make AJAX requests from the browser to &lt;code&gt;bleve-hosted&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update your layout to include these javascript files.  For many sites this will be in a file like &lt;code&gt;layouts/partial/footer.html&lt;/code&gt; or &lt;code&gt;themes/&amp;lt;your theme&amp;gt;/layouts/partials/footer.html&lt;/code&gt;.  In the section where javascript files are being included you&amp;rsquo;ll want to add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;/js/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;/js/handlebars.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;/js/search.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, we need to update search.js to point to the correct URL for &lt;code&gt;bleve-hosted&lt;/code&gt;.  On line 2 of &lt;code&gt;static/js/search.js&lt;/code&gt; modify the value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var searchURL = &#39;http://&amp;lt;your server&amp;gt;:8080/api/search.bleve/_search&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;try-it-out:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Try it Out&lt;/h3&gt;

&lt;p&gt;Now, you&amp;rsquo;re ready to regenerate your site and try it out.  If you open your browser to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://localhost:1313/search
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see the standard search box.  If you type in your query, the page should reload and display search results below.  If you run into problems, it may be helpful to view the javascript console.&lt;/p&gt;

&lt;h3 id=&#34;finishing-touches:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Finishing Touches&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s also add search to the navigation bar.  For our site, we modified the partial &lt;code&gt;navbar.html&lt;/code&gt; to include the following inside the navigation unordered-list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;div class=&amp;quot;dropdown pull-right&amp;quot;&amp;gt;
      &amp;lt;form class=&amp;quot;navbar-form&amp;quot; role=&amp;quot;search&amp;quot; action=&amp;quot;/search&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;input-group&amp;quot;&amp;gt;
            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;Search&amp;quot; name=&amp;quot;q&amp;quot; id=&amp;quot;srch-term&amp;quot;&amp;gt;
            &amp;lt;div class=&amp;quot;input-group-btn&amp;quot;&amp;gt;
                &amp;lt;button class=&amp;quot;btn btn-default&amp;quot; type=&amp;quot;submit&amp;quot;&amp;gt;&amp;lt;i class=&amp;quot;glyphicon glyphicon-search&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;future:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Future&lt;/h3&gt;

&lt;p&gt;Is this perfect? No, not really, there are a still a lot of rough edges we&amp;rsquo;d like to smooth out.  Here are some of our ideas for the future:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Enable running &lt;code&gt;bleve-hosted&lt;/code&gt; in Google App Engine.  This lowers the bar for hosting your index.&lt;/li&gt;
&lt;li&gt;Streamline the addition of search to your site.  The manual copying of multiple files and editing paths is error prone.  Perhaps additional sub-commands of &lt;code&gt;hugoidx&lt;/code&gt; could assist with this.&lt;/li&gt;
&lt;li&gt;Document worklfow for keeping your site AND your search index up to date.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Having problems with these instructions?  Let us know via &lt;a href=&#34;mailto:info@blevesearch.com&#34;&gt;email&lt;/a&gt; or the &lt;a href=&#34;https://groups.google.com/forum/#!forum/bleve&#34;&gt;Google Group&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GopherCon Lightning Talk</title>
      <link>http://www.blevesearch.com/events/gopherCon2015/</link>
      <pubDate>Fri, 10 Jul 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/events/gopherCon2015/</guid>
      <description>&lt;p&gt;The GopherCon lightning talk was a success!  It was great to meet so many Bleve users at GopherCon.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/blevesearch/gophercon15/blob/master/bleve-gophercon15.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Video:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/9nSA5L8lO0A&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Site Migrated to Hugo</title>
      <link>http://www.blevesearch.com/news/Site-Migrated-to-Hugo/</link>
      <pubDate>Thu, 02 Jul 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/news/Site-Migrated-to-Hugo/</guid>
      <description>

&lt;p&gt;You may notice the site looks a little different today.  We&amp;rsquo;ve just launched a version of the site built with &lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;.  The site is functional, but still also very much a work in progress.  Don&amp;rsquo;t hesitate to report any problems you find.&lt;/p&gt;

&lt;h3 id=&#34;why-did-we-make-the-change:871bbe6ca1368764a58ff754bed0e978&#34;&gt;Why did we make the change?&lt;/h3&gt;

&lt;p&gt;Our initial site was just a set of 3 static HTML files.  With so few files, it was reasonable to just copy/paste the headers/footers, etc.  But Bleve is growing, and as we continue to progress our site needs more pages.  Moving beyond just a few pages requires us to use some automation.  I&amp;rsquo;ve used Hugo to build small sites in the past and it&amp;rsquo;s worked great.  And we&amp;rsquo;re happy to support another Go project.&lt;/p&gt;

&lt;h3 id=&#34;site-changes:871bbe6ca1368764a58ff754bed0e978&#34;&gt;Site Changes&lt;/h3&gt;

&lt;p&gt;For the most part you&amp;rsquo;ll find the current site looks similar to the previous site.  The biggest change is that we&amp;rsquo;ve moved our documentation from the Github Wiki into the website itself.  Initially we liked the idea of using the wiki for documentation, particularly because it has such a low bar for users to contribute content.  But, with very little contribution actually happening, we feel there will be more benefits to bringing it into the website.&lt;/p&gt;

&lt;h3 id=&#34;what-about-search:871bbe6ca1368764a58ff754bed0e978&#34;&gt;What about Search?&lt;/h3&gt;

&lt;p&gt;Previously we offered an integrated github wiki search on the website, and as of today that is now missing.  However, stay tuned for future announcements!  Bleve site and documentation search will be back.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Videos</title>
      <link>http://www.blevesearch.com/videos/</link>
      <pubDate>Thu, 25 Jun 2015 12:25:45 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/videos/</guid>
      <description>

&lt;h3 id=&#34;fosdem-2015:a45b24697a235d080c581c0ce5a9b90b&#34;&gt;FOSDEM 2015&lt;/h3&gt;

&lt;p&gt;An introduction to the Bleve project given at the Go Devroom at FOSDEM 2015.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/Vhc_1Ta3Mi0&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h3 id=&#34;gophercon-india-2015:a45b24697a235d080c581c0ce5a9b90b&#34;&gt;GopherCon India 2015&lt;/h3&gt;

&lt;p&gt;An introduction to the Bleve project given at GopherCon India in Bengaluru.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/uEhs_xrWJNw&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h3 id=&#34;bleve-analysis-wizard:a45b24697a235d080c581c0ce5a9b90b&#34;&gt;Bleve Analysis Wizard&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;http://analysis.blevesearch.com/&#34;&gt;Bleve Text Analysis Wizard&lt;/a&gt; is a tool to help users experiment with the effects different analyzers have on their text.  Below is a short video showing how the tool works.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/CEfaIlzki5U&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h3 id=&#34;bleve-explorer:a45b24697a235d080c581c0ce5a9b90b&#34;&gt;Bleve Explorer&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/blevesearch/bleve-explorer&#34;&gt;Bleve Explorer&lt;/a&gt; is an example application to show how to integrate bleve with an HTTP/REST/JSON interface.  Below is a short video showing how the application works.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34;&gt;
	&lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/DfbRTXE5n4Y&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
	&lt;/iframe&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Community</title>
      <link>http://www.blevesearch.com/community/</link>
      <pubDate>Tue, 23 Jun 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/community/</guid>
      <description>

&lt;h3 id=&#34;twitter:f3b3effc19b97b19aaf2ce392427d255&#34;&gt;Twitter&lt;/h3&gt;

&lt;p&gt;Follow @blevesearch on &lt;a href=&#34;https://twitter.com/blevesearch&#34;&gt;twitter&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;irc:f3b3effc19b97b19aaf2ce392427d255&#34;&gt;IRC&lt;/h3&gt;

&lt;p&gt;Join the #bleve channel on &lt;a href=&#34;https://freenode.net/&#34;&gt;freenode&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;google-group:f3b3effc19b97b19aaf2ce392427d255&#34;&gt;Google Group&lt;/h3&gt;

&lt;p&gt;Discuss use and development of bleve is in &lt;a href=&#34;https://groups.google.com/forum/#!forum/bleve&#34;&gt;this google group&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;gitter:f3b3effc19b97b19aaf2ce392427d255&#34;&gt;Gitter&lt;/h3&gt;

&lt;p&gt;Join the conversation on &lt;a href=&#34;https://gitter.im/blevesearch/bleve&#34;&gt;Gitter&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building</title>
      <link>http://www.blevesearch.com/docs/Building/</link>
      <pubDate>Tue, 23 Jun 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/docs/Building/</guid>
      <description>

&lt;p&gt;The core of bleve can be built without any C/C++ libraries.  This means you can get and use bleve with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/blevesearch/bleve/...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, some of the more advanced functionality depends on C/C++ libraries.  The code using these libraries can be enabled by specifying the correct build tag.&lt;/p&gt;

&lt;p&gt;In general, bleve expects these libraries to be built and installed in the standard system locations.  If not, it is up to you to set the appropriate CGO_&amp;hellip; environment variables so that the libraries and headers can be found.&lt;/p&gt;

&lt;h2 id=&#34;leveldb:140c58546f80295ba58ab4d2981832fc&#34;&gt;LevelDB&lt;/h2&gt;

&lt;p&gt;Bleve supports using &lt;a href=&#34;https://code.google.com/p/leveldb/&#34;&gt;LevelDB&lt;/a&gt; as a KVStore implementation.  At this time, this is the fastest KVStore implementation available for bleve.  So if maximum performance is your goal, consider building with support for LevelDB.&lt;/p&gt;

&lt;p&gt;To include support for the leveldb KVStore implementation include the build tag:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-tags leveldb&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;icu:140c58546f80295ba58ab4d2981832fc&#34;&gt;ICU&lt;/h2&gt;

&lt;p&gt;Bleve supports using the &lt;a href=&#34;http://site.icu-project.org/&#34;&gt;ICU&lt;/a&gt; project to tokenize words using their implementation of the standard for &lt;a href=&#34;http://www.unicode.org/reports/tr29/&#34;&gt;Unicode Text Segmentation at Word Boundaries&lt;/a&gt;.  Some of the language specific analyzers depend on this tokenizer.&lt;/p&gt;

&lt;p&gt;NOTE: It is recommended to get the most recent version of ICU possible.  Older versions often included with distributions do not support language based tokenization.&lt;/p&gt;

&lt;p&gt;To include support for the analysis components requiring ICU, include the build tag:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-tags icu&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;libstemmer:140c58546f80295ba58ab4d2981832fc&#34;&gt;libstemmer&lt;/h2&gt;

&lt;p&gt;Bleve supports using the &lt;a href=&#34;http://snowball.tartarus.org/download.php&#34;&gt;libstemmer&lt;/a&gt; library to stem words for many languages.  Many of the language specific analyzers depend on this library.&lt;/p&gt;

&lt;p&gt;To include support for the analysis components requiring libstemmer, include the build tag:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-tags libstemmer&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;cld2:140c58546f80295ba58ab4d2981832fc&#34;&gt;cld2&lt;/h2&gt;

&lt;p&gt;Bleve supports using the &lt;a href=&#34;https://code.google.com/p/cld2/&#34;&gt;cld2&lt;/a&gt; library to determine the language of a sample of text.  This is implemented as a token filter which will return the result as a ISO 639 language code.&lt;/p&gt;

&lt;p&gt;To include support for the detect_lang token filter, include the build tag:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-tags cld2&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;short-cut-to-include-all-the-optional-dependencies:140c58546f80295ba58ab4d2981832fc&#34;&gt;Short-cut to include all the optional dependencies&lt;/h2&gt;

&lt;p&gt;Building with multiple build tags can be cumbersome:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-tags &#39;leveldb icu libstemmer cld2&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As a shortcut you can instead use:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-tags full&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;platform-specific-instructions:140c58546f80295ba58ab4d2981832fc&#34;&gt;Platform Specific Instructions&lt;/h2&gt;

&lt;p&gt;The following sections are user-contributed instructions for satisfying all the dependencies on particular platforms.&lt;/p&gt;

&lt;h3 id=&#34;ubuntu-14-04-lts-trusty-tahr:140c58546f80295ba58ab4d2981832fc&#34;&gt;Ubuntu 14.04 LTS (Trusty Tahr)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install libleveldb-dev libstemmer-dev libicu-dev svn build-essential
$ go get -u -v  github.com/blevesearch/bleve
$ cd $GOPATH/src/github.com/blevesearch/bleve/analysis/token_filters/cld2
$ svn co http://cld2.googlecode.com/svn/trunk cld2-read-only
$ cd cld2-read-only/internal/
$ ./compile_libs.sh
$ sudo cp *.so /usr/local/lib
$ go get -u -v -tags full github.com/blevesearch/bleve
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;os-x-hacky-but-similar-to-ubuntu-14-04:140c58546f80295ba58ab4d2981832fc&#34;&gt;OS X (hacky, but similar to Ubuntu 14.04)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ brew install leveldb icu4c svn # etc?
$ export CGO_LDFLAGS=-L/usr/local/opt/icu4c/lib
$  export CGO_CFLAGS=-I/usr/local/opt/icu4c/include
$ go get -u -v  github.com/blevesearch/bleve
$ cd $GOPATH/src/github.com/blevesearch/bleve/analysis/token_filters/cld2
$ svn co http://cld2.googlecode.com/svn/trunk cld2-read-only
$ cd cld2-read-only/internal/
# if you feel gutsy run:
$ perl -p -i -e &#39;s/soname=/install_name,/&#39; compile_libs.sh
# otherwise, just change soname= to install_name, in the two spots in compile_libs.sh
$ ./compile_libs.sh
$ sudo cp *.so /usr/local/lib
$ go get -u -v -tags full github.com/blevesearch/bleve
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Applications Using Bleve</title>
      <link>http://www.blevesearch.com/docs/Applications-using-bleve/</link>
      <pubDate>Tue, 23 Jun 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/docs/Applications-using-bleve/</guid>
      <description>

&lt;p&gt;The following applications use bleve.  Add yours to the list!&lt;/p&gt;

&lt;h2 id=&#34;caddy:640b2c4c13c05d4abaa6d9659bc2b04d&#34;&gt;Caddy&lt;/h2&gt;

&lt;p&gt;Caddy is an alternative web server that is easy to configure and use.  Caddy uses Bleve to automatically index your site and expose a search page and JSON endpoint.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://caddyserver.com/docs/search&#34;&gt;https://caddyserver.com/docs/search&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cbft:640b2c4c13c05d4abaa6d9659bc2b04d&#34;&gt;cbft&lt;/h2&gt;

&lt;p&gt;Full-text searches of Couchbase Server, powered by bleve.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/couchbaselabs/cbft&#34;&gt;https://github.com/couchbaselabs/cbft&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker-bleve-wiki-indexer:640b2c4c13c05d4abaa6d9659bc2b04d&#34;&gt;docker bleve wiki indexer&lt;/h2&gt;

&lt;p&gt;Dockerizing the bleve library to search the bleve wiki.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/lgs/docker-bleve-wiki-indexer&#34;&gt;https://github.com/lgs/docker-bleve-wiki-indexer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;goin:640b2c4c13c05d4abaa6d9659bc2b04d&#34;&gt;goin&lt;/h2&gt;

&lt;p&gt;A full text search indexer for your files on disk.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bitbucket.org/zaphar/goin&#34;&gt;https://bitbucket.org/zaphar/goin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tpb-search:640b2c4c13c05d4abaa6d9659bc2b04d&#34;&gt;tpb-search&lt;/h2&gt;

&lt;p&gt;Locally index and search database dumps from &lt;a href=&#34;https://openbay.isohunt.to&#34;&gt;https://openbay.isohunt.to&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/peterhellberg/tpb-search&#34;&gt;https://github.com/peterhellberg/tpb-search&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ekanite:640b2c4c13c05d4abaa6d9659bc2b04d&#34;&gt;Ekanite&lt;/h2&gt;

&lt;p&gt;A Syslog server with built-in search for received log messages.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ekanite/ekanite&#34;&gt;https://github.com/ekanite/ekanite&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Analyzers</title>
      <link>http://www.blevesearch.com/docs/Analyzers/</link>
      <pubDate>Tue, 23 Jun 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/docs/Analyzers/</guid>
      <description>

&lt;h2 id=&#34;general-purpose-analyzers:aa66feb1a6a343065211b619ad078082&#34;&gt;General Purpose Analyzers&lt;/h2&gt;

&lt;h3 id=&#34;keyword:aa66feb1a6a343065211b619ad078082&#34;&gt;Keyword&lt;/h3&gt;

&lt;p&gt;The Keyword Analyzer does not perform any analysis on the input text.  It creates a single token representing the entire input.  This is useful for fields where you only want exact matches.  For example, a field containing keywords or tags that may contain spaces that another analyzer might interpret as token boundaries.&lt;/p&gt;

&lt;h3 id=&#34;simple:aa66feb1a6a343065211b619ad078082&#34;&gt;Simple&lt;/h3&gt;

&lt;p&gt;The simple analyzer performs only minimal analysis on the input.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tokenizer - &lt;a href=&#34;http://www.blevesearch.com/docs/Tokenizers/#unicode:7d5ef314ed49959990583aa48ce5f86b&#34;&gt;Unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Token Filters

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.blevesearch.com/docs/Token-Filters/#lowercase:c38efc402d8771527a225c32b59be157&#34;&gt;Lowercase&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;standard:aa66feb1a6a343065211b619ad078082&#34;&gt;Standard&lt;/h3&gt;

&lt;p&gt;The Standard Analyzer is like the Simple Analyzer but also adds English stop word removal.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tokenizer - &lt;a href=&#34;http://www.blevesearch.com/docs/Tokenizers/#unicode:7d5ef314ed49959990583aa48ce5f86b&#34;&gt;Unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Token Filters

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.blevesearch.com/docs/Token-Filters/#lowercase:c38efc402d8771527a225c32b59be157&#34;&gt;Lowercase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;English &lt;a href=&#34;http://www.blevesearch.com/docs/Token-Filters/#stop-token:c38efc402d8771527a225c32b59be157&#34;&gt;Stop Token&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;detect-language:aa66feb1a6a343065211b619ad078082&#34;&gt;Detect Language&lt;/h3&gt;

&lt;p&gt;The Detect Language Analyzer is used to examine input text, use heuristics to determine a best guess at the language, and index the ISO 639 Language Code.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tokenizer - &lt;a href=&#34;http://www.blevesearch.com/docs/Tokenizers/#single-token:7d5ef314ed49959990583aa48ce5f86b&#34;&gt;Single&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Token Filters

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.blevesearch.com/docs/Token-Filters/#lowercase:c38efc402d8771527a225c32b59be157&#34;&gt;Lowercase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.blevesearch.com/docs/Token-Filters/#cld2:c38efc402d8771527a225c32b59be157&#34;&gt;CLD2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;language-specific-analyzers:aa66feb1a6a343065211b619ad078082&#34;&gt;Language Specific Analyzers&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Danish&lt;/li&gt;
&lt;li&gt;Dutch&lt;/li&gt;
&lt;li&gt;English&lt;/li&gt;
&lt;li&gt;Finnish&lt;/li&gt;
&lt;li&gt;French&lt;/li&gt;
&lt;li&gt;Hungarian&lt;/li&gt;
&lt;li&gt;Italian&lt;/li&gt;
&lt;li&gt;German&lt;/li&gt;
&lt;li&gt;Norwegian&lt;/li&gt;
&lt;li&gt;Persian&lt;/li&gt;
&lt;li&gt;Portuguese&lt;/li&gt;
&lt;li&gt;Romanian&lt;/li&gt;
&lt;li&gt;Russian&lt;/li&gt;
&lt;li&gt;Sorani&lt;/li&gt;
&lt;li&gt;Spanish&lt;/li&gt;
&lt;li&gt;Swedish&lt;/li&gt;
&lt;li&gt;Thai&lt;/li&gt;
&lt;li&gt;Turkish&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Character Filters</title>
      <link>http://www.blevesearch.com/docs/Character-Filters/</link>
      <pubDate>Tue, 23 Jun 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/docs/Character-Filters/</guid>
      <description>

&lt;h3 id=&#34;regular-expression:332c3eea69ab462e14d779b7c7983cd1&#34;&gt;Regular Expression&lt;/h3&gt;

&lt;p&gt;The regular expression character filter is configured with a regular expression and a replacement array of bytes.  All sequences of characters matching the regular expression are replaced with the replacement bytes.&lt;/p&gt;

&lt;p&gt;Typically, characters that are undesirable for indexing are replaced with whitespace.  This allows the original byte offsets in the original input to remain unaffected.&lt;/p&gt;

&lt;h3 id=&#34;html:332c3eea69ab462e14d779b7c7983cd1&#34;&gt;HTML&lt;/h3&gt;

&lt;p&gt;The html character filter attempts to identify HTML tags from the input text and replace them with spaces.  The current implementation is an instance of the Regular Expression character filter.&lt;/p&gt;

&lt;h3 id=&#34;zero-width-non-joiner:332c3eea69ab462e14d779b7c7983cd1&#34;&gt;Zero-width Non-Joiner&lt;/h3&gt;

&lt;p&gt;The zero-width non-joiner character filter replaces zero-width non-joiner characters with a space.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ignore/Disable Sections of Documents</title>
      <link>http://www.blevesearch.com/docs/Disabling%20Sections%20of%20Documents/</link>
      <pubDate>Tue, 23 Jun 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/docs/Disabling%20Sections%20of%20Documents/</guid>
      <description>&lt;p&gt;Sometimes documents contains sections of content you simply want to ignore.  Let&amp;rsquo;s imagine we have the following structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Person struct {
    Name string
    Addr Address
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, we&amp;rsquo;ve decided we don&amp;rsquo;t want to index or store any of the address data.  We can accomplish this by using the following DocumentMapping.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;addressMapping := bleve.NewDocumentDisabledMapping()
personMapping := bleve.NewDocumentMapping()
personMapping.AddSubDocumentMapping(&amp;quot;Addr&amp;quot;, addressMapping)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Contributing</title>
      <link>http://www.blevesearch.com/docs/Contributing/</link>
      <pubDate>Tue, 23 Jun 2015 10:25:38 -0400</pubDate>
      
      <guid>http://www.blevesearch.com/docs/Contributing/</guid>
      <description>&lt;p&gt;As bleve is a Couchbase project we must require contributors accept the &lt;a href=&#34;http://review.couchbase.org/static/individual_agreement.html&#34;&gt;Couchbase Contributor License Agreement&lt;/a&gt;.  To sign this agreement log into the Couchbase &lt;a href=&#34;http://review.couchbase.org/&#34;&gt;code review tool&lt;/a&gt;.  The bleve project does not use this code review tool but it is still used to track acceptance of the contributor license agreements.&lt;/p&gt;

&lt;p&gt;All types of contributions are welcome, but please keep the following in mind:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If you&amp;rsquo;re planning a large change, you should really discuss it on the &lt;a href=&#34;https://groups.google.com/forum/#!forum/bleve&#34;&gt;google group&lt;/a&gt; first.  This helps avoid duplicate effort and spending time on something that may not be merged.&lt;/li&gt;
&lt;li&gt;Existing tests should continue to pass, new tests for the contribution are nice to have.&lt;/li&gt;
&lt;li&gt;All code should have gone through &lt;code&gt;go fmt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;All code should pass &lt;code&gt;go vet&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>