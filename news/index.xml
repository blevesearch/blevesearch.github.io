<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>News on Bleve</title>
    <link>https://www.blevesearch.com/news/</link>
    <description>Recent content in News on Bleve</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© &lt;a href=&#34;http://couchbase.com/&#34;&gt;Couchbase&lt;/a&gt; 2015-2018</copyright>
    <lastBuildDate>Mon, 28 Sep 2015 10:40:38 -0400</lastBuildDate>
    <atom:link href="https://www.blevesearch.com/news/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Deferred Cleanup, Checking Errors, and Potential Problems</title>
      <link>https://www.blevesearch.com/news/Deferred-Cleanup,-Checking-Errors,-and-Potential-Problems/</link>
      <pubDate>Mon, 28 Sep 2015 10:40:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/news/Deferred-Cleanup,-Checking-Errors,-and-Potential-Problems/</guid>
      <description>

&lt;p&gt;The &lt;em&gt;defer&lt;/em&gt; statement in Go is frequently used to ensure that once a resource has been acquired, it will be properly cleaned up.  In its simplest form it works exactly as you expect.  But, as you move to more advanced usages there are some things to watch out for.  I&amp;rsquo;d like to share one that I recently ran into while writing Bleve test cases.&lt;/p&gt;

&lt;h3 id=&#34;basics:ffe76477ce26feb5927595f82ec07acf&#34;&gt;Basics&lt;/h3&gt;

&lt;p&gt;The power of the &lt;em&gt;defer&lt;/em&gt; statement in Go is that it lets you put the acquisition and cleanup of a resource side by side.  When you read code later, it&amp;rsquo;s easy to see that the correct behavior is guaranteed.  Let&amp;rsquo;s take a look at a simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer r.Close()
}

type Resource struct {
	name string
}

func Open(name string) (*Resource, error) {
	return &amp;amp;Resource{name}, nil
}

func (r *Resource) Close() error {
	log.Printf(&amp;quot;closing %s\n&amp;quot;, r.name)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/fYB2alVcIw&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The main function shows some very common behavior.  Open a resource, check for an error, then &lt;em&gt;defer&lt;/em&gt; Closing the resource.  When we run this, we get the expected behavior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing a
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;opening-another-resource-reusing-the-variable:ffe76477ce26feb5927595f82ec07acf&#34;&gt;Opening another Resource, Reusing the Variable&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s make the example a bit more complex.  Now, after closing the resource, we will open another one (with a different name).  Can we reuse the same variable?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer r.Close()

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer r.Close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/Bal_y0nv4U&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When I was new to Go and first encountered this code I wasn&amp;rsquo;t sure if this would work.  I knew that &lt;em&gt;defer&lt;/em&gt; would not execute until the end of main, but would it close &amp;lsquo;a&amp;rsquo; AND &amp;lsquo;b&amp;rsquo;?  Or would it close &amp;lsquo;b&amp;rsquo; twice?  If we run it we see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing b
2009/11/10 23:00:00 closing a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, it does work, this is the expected output.  Some of you may be wondering, but &lt;em&gt;why&lt;/em&gt; does it work?  As the Go blog &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34;&gt;Defer, Panic, and Recover&lt;/a&gt; explains,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A deferred function&amp;rsquo;s arguments are evaluated when the defer statement is evaluated.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In our case, the method receiver &amp;lsquo;r&amp;rsquo; for the Close() method behaves just like an argument.  So the &amp;lsquo;r&amp;rsquo; is evaluated at the time the defer statement is evaluated, and &lt;em&gt;NOT&lt;/em&gt; when the statement is executed.  In Bleve code we saw this pattern occur frequently in test cases.  We would acquire a resource, take some action, close the resource, check the state of things, then repeat the process.&lt;/p&gt;

&lt;h3 id=&#34;errcheck:ffe76477ce26feb5927595f82ec07acf&#34;&gt;errcheck?&lt;/h3&gt;

&lt;p&gt;Last February I had the amazing opportunity to attend &lt;a href=&#34;http://www.gophercon.in/&#34;&gt;GopherCon India&lt;/a&gt;.  One of the many things I learned while there was of a tool called &lt;a href=&#34;https://github.com/kisielk/errcheck&#34;&gt;errcheck&lt;/a&gt;.  The idea of the tool is simple, it looks at your Go code and identifies places where you&amp;rsquo;re not checking a returned error.  This seemed like such an obvious thing to do, so I ran it on the entire Bleve codebase.  We found several clear cases where an error was returned, and we would not propagate the error back to the caller.&lt;/p&gt;

&lt;p&gt;But what happens if we run &lt;em&gt;errcheck&lt;/em&gt; on the code we just wrote above?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github.com/mschoch/defertest/main.go:10:15	defer r.Close()
github.com/mschoch/defertest/main.go:16:15	defer r.Close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Close() method returns an error.  Although it&amp;rsquo;s not used in this contrived example, I coded it that way on purpose as that is very common in the real world.  Does checking this error matter?  If closing the first resource results in an error, should you try to close the second one?  In the abstract these are interesting philosophical questions, but let&amp;rsquo;s assume we do want to check the errors.  How would we do it?  My first attempt looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer func() {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer func() {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/_MPUl6zWjF&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I added an anonymous function which invokes r.Close(), checks the error, and if its non-nil we exit the program through log.Fatal().  It seems like such a simple change, but we&amp;rsquo;ve introduced a severe bug into the code.  In our case we can see it clearly since we&amp;rsquo;re printing out the name of the resource being closed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing b
2009/11/10 23:00:00 closing b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oops!  We&amp;rsquo;re now closing the &amp;lsquo;b&amp;rsquo; resource twice, and never closing the &amp;lsquo;a&amp;rsquo; resource.  This is a severe problem, closing &amp;lsquo;b&amp;rsquo; a second time may not be well defined behavior, and not closing &amp;lsquo;a&amp;rsquo; may leak resources.&lt;/p&gt;

&lt;p&gt;Where did we go wrong?  Remember the rule we were given was:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A deferred function&amp;rsquo;s arguments are evaluated when the defer statement is evaluated.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And in our new code, the deferred function has no arguments, and no method receiver.  We&amp;rsquo;re now relying the anonymous function referring to &amp;lsquo;r&amp;rsquo;.  The Go spec says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;rdquo;&amp;hellip;they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, now it&amp;rsquo;s fairly clear what happened.  At the time the &lt;em&gt;defer&lt;/em&gt; statement was evaluated, the arguments were evaluated, but there were none.  Then at the end of the function, the deferred function is executed, and &lt;em&gt;now&lt;/em&gt; as the anonymous functions are executed, &amp;lsquo;r&amp;rsquo; is evaluated, and in both cases it refers to &amp;lsquo;b&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;the-fix:ffe76477ce26feb5927595f82ec07acf&#34;&gt;The Fix&lt;/h3&gt;

&lt;p&gt;Option 1, we can rewrite the &lt;em&gt;defer&lt;/em&gt; statement to pass &amp;lsquo;r&amp;rsquo; as an argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer func(r *Resource) {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}(r)

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer func(r *Resource) {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}(r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This does give the correct output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2009/11/10 23:00:00 closing b
2009/11/10 23:00:00 closing a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But, to be honest, it&amp;rsquo;s rather verbose.  In many cases it may just be simpler to use a different variable name.  Option 2, use a new variable for the second resource:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer func() {
		err := r.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()

	r2, err := Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer func() {
		err := r2.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;UPDATE: 2015-09-29&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Users &lt;a href=&#34;https://www.reddit.com/r/golang/comments/3mqxar/deferred_cleanup_checking_errors_and_potential/&#34;&gt;discussing this on Reddit&lt;/a&gt; proposed a third option.  Create a named cleanup function and use the existing io.Closer interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	r, err := Open(&amp;quot;a&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;a&#39;\n&amp;quot;)
	}
	defer Close(r)

	r, err = Open(&amp;quot;b&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;error opening &#39;b&#39;\n&amp;quot;)
	}
	defer Close(r)
}

func Close(c io.Closer) {
	err := c.Close()
	if err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/ZjlavK1r6N&#34;&gt;Run this in the Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As I mentioned earlier, in Bleve this pattern only seems to arise in test cases.  I suspect in real code you&amp;rsquo;d be more likely to already be using more descriptive identifiers.&lt;/p&gt;

&lt;h3 id=&#34;summary:ffe76477ce26feb5927595f82ec07acf&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;To me the lesson here is that we had a simple pattern for deferred cleanup that worked.  I even explicitly took the time to verify that it cleaned up the correct resources when I reused variables.  Then I took the seemingly natural step to make sure we check all the returned errors.  But, I was a bit careless and overlooked that the deferred anonymous function can have significantly different behavior.  It wasn&amp;rsquo;t until I observed problems that I went back to recheck my assumptions and track down the problem.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Faster Tokenization with Ragel generated FSM</title>
      <link>https://www.blevesearch.com/news/Faster-Tokenization-with-Ragel-generated-FSM/</link>
      <pubDate>Tue, 08 Sep 2015 10:40:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/news/Faster-Tokenization-with-Ragel-generated-FSM/</guid>
      <description>

&lt;p&gt;Text processed by Bleve must first go through the process of tokenization.  Read on to learn how we sped up the process by a factor of 2x by introducing an FSM generated by &lt;a href=&#34;https://www.colm.net/open-source/ragel/&#34;&gt;Ragel&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tokenization:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Tokenization?&lt;/h3&gt;

&lt;p&gt;Tokenization is the process by which we take a string like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;Using Ragel to tokenize 2.1x faster.&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And turn it into discrete tokens:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;Using&amp;quot;, &amp;quot;Ragel&amp;quot;, &amp;quot;to&amp;quot;, &amp;quot;tokenize&amp;quot;, &amp;quot;2.1x&amp;quot;, &amp;quot;faster&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Your first thought might be that we can simply split the text up using the Unicode White Space property.  And for simple use cases that might be good enough, but you still have to handle removing punctuation.  Unicode defines properties for that as well, but if we want to retain &lt;code&gt;2.1x&lt;/code&gt; as is, we can&amp;rsquo;t simply remove all punctuation.  Fortunately, the Unicode specification has already addressed this problem and defined rules for word segmentation.&lt;/p&gt;

&lt;h3 id=&#34;unicode-text-segmentation:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Unicode Text Segmentation&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;re interested in all details, see &lt;a href=&#34;http://unicode.org/reports/tr29/&#34;&gt;UnicodeÂ® Standard Annex #29&lt;/a&gt;.  What matters for this discussion is that it defines a set of rules, based on which characters occur before and after others, to decide whether or not to break up the text.&lt;/p&gt;

&lt;p&gt;Our first solution was simply to integrate with the C library &lt;a href=&#34;http://site.icu-project.org/&#34;&gt;ICU&lt;/a&gt;.  This got us up and running quickly, but having a dependency on ICU was not a long term solution.&lt;/p&gt;

&lt;p&gt;Next, I set out to write my own implementation.  I followed the lead I found in the Go standard library&amp;rsquo;s &lt;a href=&#34;https://github.com/golang/go/tree/master/src/unicode&#34;&gt;unicode package&lt;/a&gt;, and wrote code which generated &lt;code&gt;unicode.RangeTable&lt;/code&gt;s for all the properties defined by the word segmentation rules.  Next, I wrote a for loop which walked through the slice of bytes, kept track of which types of characters occurred in sequence, and returned the segmented text at the appropriate places.  Fortunately, the Unicode specification also includes test cases, so after banging on the code for a while I had something that worked.&lt;/p&gt;

&lt;p&gt;While it was great that it was working, it had some serious drawbacks.  First, if the rules evolve in a newer Unicode spec, updating this code base could be tricky.  Second, while it performed good enough to use, I always knew that the for-loops and Unicode range table lookups were not optimal.&lt;/p&gt;

&lt;h3 id=&#34;a-generated-fsm-solution:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;A Generated FSM Solution&lt;/h3&gt;

&lt;p&gt;The appeal of a generated FSM solution was that we could keep the rule definitions at a high level.  This lets us easily modify them as they change, and it also allows for the possibility of customization in the future.  Second, the generated code should be able to take advantage of well understood FSM techniques and perform faster than my hand-rolled for-loop.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve gone looking for FSM solutions in the Go ecosystem in the past and never found one that seemed to meet my needs.  This time however, I came across someone suggesting &lt;a href=&#34;https://www.colm.net/open-source/ragel/&#34;&gt;Ragel&lt;/a&gt;.  To be honest, approaching a project like this can be daunting.  Just looking at the example on their home page you realize you have to learn their DSL.  Sure it&amp;rsquo;s rooted in regular-expressions, but the full syntax goes beyond that.  The documentation looked solid, but I still wondered, how good is Go code generator?  The code isn&amp;rsquo;t on github and there doesn&amp;rsquo;t appear to be any community around it. Am I going to invest a day learning this just to hit some dead end?&lt;/p&gt;

&lt;p&gt;I was desperate, so I dove in despite my concerns&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;ragel:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Ragel&lt;/h3&gt;

&lt;p&gt;I started by trying to write a test program, just to get comfortable writing rules in Ragel and generating Go code.  I came across this project &lt;a href=&#34;https://github.com/acsellers/ragel-go-examples&#34;&gt;ragel-go-examples&lt;/a&gt;, which I recommend to anyone else getting started.&lt;/p&gt;

&lt;p&gt;Once comfortable with the basics, I needed to start working towards something resembling the Unicode word segmentation rules.  I had two things to work off of:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The Ragel distribution includes a script &lt;code&gt;contrib/unicode2ragel.rb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The Lucene source has &lt;a href=&#34;https://github.com/apache/lucene-solr/blob/8372b0f5a3c01dae28eeb70b6a0510a6170c57c5/lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.jflex&#34;&gt;jflex rules&lt;/a&gt; for segmentation which share the same regular-expression roots&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;unicode2ragel.rb&lt;/code&gt; script would take the Unicode properties file and create ragel rules matching the corresponding utf-8 byte sequences.  Unfortunately it was hard-coded to work with a particular file, and only export particular properties.  I was able to modify this script to work off an arbitrary URL and export whichever named properties you wanted.  This let me generate Ragel rules for the properties defined in the word segmentation specification.&lt;/p&gt;

&lt;p&gt;Next, I hand converted the jflex rules in the Lucene source into the Ragel language.&lt;/p&gt;

&lt;p&gt;Finally, our existing &lt;code&gt;segment&lt;/code&gt; package had an API that we wanted to continue to support.  So I spent about another half-day attaching the right Ragel actions to the rules and massaging it to fit the API.&lt;/p&gt;

&lt;h3 id=&#34;performance:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Performance&lt;/h3&gt;

&lt;p&gt;Ragel supports 7 different code output styles, some table based, others goto based.  Benchmarking the different options showed that &lt;code&gt;-G2&lt;/code&gt; (goto, with in-place actions) yielded the highest performance.  When compared against the original for-loop version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ benchcmp before.txt after.txt 
benchmark                          old ns/op     new ns/op     delta
BenchmarkSplitWords-4              966830        457480        -52.68%
BenchmarkWordSegmenter-4           1004317       486750        -51.53%
BenchmarkWordSegmenterDirect-4     970841        463655        -52.24%

benchmark                          old allocs     new allocs     delta
BenchmarkSplitWords-4              20             20             +0.00%
BenchmarkWordSegmenter-4           36             36             +0.00%
BenchmarkWordSegmenterDirect-4     32             32             +0.00%

benchmark                          old bytes     new bytes     delta
BenchmarkSplitWords-4              380966        380971        +0.00%
BenchmarkWordSegmenter-4           496429        496432        +0.00%
BenchmarkWordSegmenterDirect-4     467706        467709        +0.00%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not too bad, the new version is 2x as fast, with no substantial change to memory usage or allocations.&lt;/p&gt;

&lt;h3 id=&#34;all-good-no:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;All good? No&amp;hellip;&lt;/h3&gt;

&lt;p&gt;Runtime performance may be the most important metric, but it&amp;rsquo;s not the only one.  One detail I neglected to mention earlier was that when I generate the code with the &lt;code&gt;-G2&lt;/code&gt; option, the resulting go file is huge:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh segment_words.go
-rw-r--r--  1 mschoch  staff   2.6M Sep  8 10:32 segment_words.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, by itself that isn&amp;rsquo;t a problem, how does it affect the size of a program using the package?  I created a test program which segments some text and compared the size of the resulting binaries.&lt;/p&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh stest
-rwxr-xr-x  1 mschoch  staff   1.3M Sep  8 13:40 stest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh stest
-rwxr-xr-x  1 mschoch  staff   6.0M Sep  8 13:41 stest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I was pleasantly surprised by this one as I thought it might be a lot worse.  I can imagine for some use cases this is a problem, but I think for most projects this will not be significant.&lt;/p&gt;

&lt;p&gt;But, there was one more thing to check with those same programs, compilation time.&lt;/p&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time go build

real	0m0.364s
user	0m0.434s
sys	0m0.079s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time go build

real	0m4.848s
user	0m6.134s
sys	0m0.523s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, that is a bit unfortunate.  The program now takes over 4.5 seconds longer to compile.  The Ragel documentation did hint that this could be a problem, and I suspect the (temporary) slowdown in the Go 1.5 tool-chain is also contributing to the problem.&lt;/p&gt;

&lt;p&gt;For projects like Bleve this is unfortunate as we had been trying to take other steps to improve compilation time, and this wipes out all of those gains.  But, in the big picture I suspect most projects would prefer the 2x runtime gain.&lt;/p&gt;

&lt;p&gt;More testing needs to be done, if one of the other output formats results in significantly faster compilation, another option would be to use build tags to control which one is used.  That way production builds get the most optimal runtime code.  But for now I&amp;rsquo;m going to let this be and see how it goes.&lt;/p&gt;

&lt;h3 id=&#34;testing-code-coverage:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Testing/Code Coverage&lt;/h3&gt;

&lt;p&gt;The Unicode specification for text segmentation also includes a suite of test strings and their correct segmentation boundaries.  We use these test cases to ensure that the behavior conforms to the specification.  I always like the fact that between that test suite and a few other well crafted strings, we were able to get the code coverage to 100%&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -coverprofile=coverage.out 
PASS
coverage: 100.0% of statements
ok  	github.com/blevesearch/segment	0.027s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, how does it look now?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -coverprofile=coverage.out 
PASS
coverage: 1.2% of statements
ok  	github.com/blevesearch/segment	0.239s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats disappointing, but not surprising.  The generated code is expanding the possible paths for efficiency, and our test set doesn&amp;rsquo;t cover nearly as many paths in the new code.&lt;/p&gt;

&lt;p&gt;Getting that number higher might be a project for another day, but I still wanted some higher confidence in this newly generated code.  And it seemed like a perfect opportunity to play with &lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;go-fuzz&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;go-fuzz:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;go-fuzz&lt;/h3&gt;

&lt;p&gt;This was my first time using go-fuzz, so I followed this &lt;a href=&#34;https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c&#34;&gt;tutorial&lt;/a&gt; by Damian Gryski.&lt;/p&gt;

&lt;p&gt;The idea was simple, I should be able to use the Unicode test suite as the initial corpus, and let go-fuzz bang away on library looking for problems.  It&amp;rsquo;s not going to help with correctness, but it can at least identify any crashes or hangs.&lt;/p&gt;

&lt;p&gt;First, I wrote a simple Fuzz function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Fuzz(data []byte) int {

	vals := make([][]byte, 0, 10000)
	types := make([]int, 0, 10000)
	if _, _, _, err := SegmentWordsDirect(data, vals, types); err != nil {
		return 0
	}
	return 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, I wrote some code to convert the test suite strings into the initial test corpus for go-fuzz.  I implemented it as a test and not a main program because the test data is only accessible from the test compilation.  You can run that with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go test -v -run=TestGenerateWordSegmentFuzz -tags gofuzz_generate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then generate the go-fuzz package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go-fuzz-build github.com/blevesearch/segment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let it run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go-fuzz -bin=segment-fuzz.zip -workdir=workdir
2015/09/08 14:19:19 slaves: 8, corpus: 1859 (0s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
2015/09/08 14:19:22 slaves: 8, corpus: 2486 (0s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 3651, uptime: 6s
2015/09/08 14:19:25 slaves: 8, corpus: 2486 (3s ago), crashers: 0, restarts: 1/6850, execs: 54804 (6068/sec), cover: 3683, uptime: 9s
... data omitted ...
2015/09/08 15:04:10 slaves: 8, corpus: 7255 (1m6s ago), crashers: 0, restarts: 1/9982, execs: 67204666 (24946/sec), cover: 20912, uptime: 44m54s
2015/09/08 15:04:13 slaves: 8, corpus: 7255 (1m9s ago), crashers: 0, restarts: 1/9985, execs: 67279017 (24945/sec), cover: 20912, uptime: 44m57s
2015/09/08 15:04:16 slaves: 8, corpus: 7265 (0s ago), crashers: 0, restarts: 1/9984, execs: 67354365 (24946/sec), cover: 20912, uptime: 45m0s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This run was for 45 minutes, I have previously let it run for several hours and it has not reported any crashers.  I was hoping this would make me feel better about things, but I still have some questions.  The documentation states that the &lt;code&gt;cover&lt;/code&gt; value is the number of bits set in a hashmap.  So more is better right?  But, the docs go on to say that the &amp;ldquo;value should be less than ~5000, otherwise fuzzer can miss new interesting inputs due to hash collisions&amp;rdquo;.  So perhaps our cover is now too high?  Maybe we&amp;rsquo;re not doing something right, so this requires more investigation.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:93bf43aa3cf12095edc0c5d6bd053746&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;In summary, I&amp;rsquo;m pretty pleased with how things have turned out.  I was initially a bit intimidated by Ragel, but in just a few days I was able to use it successfully.  The runtime performance gains will be a significant boost to projects like Bleve.  The high compilation times, code coverage and fuzzing issues are things we&amp;rsquo;ll have to keep working on going forward.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re interested, please checkout the &lt;a href=&#34;https://github.com/blevesearch/segment&#34;&gt;segment&lt;/a&gt; github repo.  If you have suggestions/ideas to help us improve it further, discuss it with us on the &lt;a href=&#34;https://groups.google.com/forum/#!forum/bleve&#34;&gt;google group&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Site Search is Back!</title>
      <link>https://www.blevesearch.com/news/Site-Search/</link>
      <pubDate>Tue, 14 Jul 2015 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/news/Site-Search/</guid>
      <description>

&lt;p&gt;We recently re-launched the Bleve website using Hugo, and we temporarily lost the ability to search the site.  Today, we bring back search, and show you how you can add search to your Hugo site.&lt;/p&gt;

&lt;p&gt;At a high level, there are three steps to adding search to your site.  First, you must build the index.  Second, you must host the index.  Third, you add a search page to your site.&lt;/p&gt;

&lt;h3 id=&#34;building-the-index:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Building the Index&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Install &lt;strong&gt;hugoidx&lt;/strong&gt; - this is the command we will use build the search index.  Anytime you update your content and regenerate your site using the &lt;code&gt;hugo&lt;/code&gt; command, you&amp;rsquo;ll also want to rebuild your search index.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/blevesearch/hugoidx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cd &amp;lt;your hugo site&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;hugoidx&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You should now have a file named &lt;code&gt;search.bleve&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;hosting-the-index:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Hosting the Index&lt;/h3&gt;

&lt;p&gt;In order to host the index we need to run a small Go program that is available on the internet.  To simplify this process, we have built a reusable application called &lt;code&gt;bleve-hosted&lt;/code&gt;.  You can use this application safely answer queries to the index (read-only operations).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Install &lt;code&gt;bleve-hosted&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/blevesearch/bleve-hosted
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cd $GOPATH/src/github.com/blevesearch/bleve-hosted&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;bleve-hosted&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Test that its working:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://localhost:8080/api/test.bleve/_search -d &#39;{&amp;quot;query&amp;quot;:{&amp;quot;query&amp;quot;:&amp;quot;bleve&amp;quot;}}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting JSON should include &amp;ldquo;total_hits&amp;rdquo;: 1&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy the &lt;code&gt;search.bleve&lt;/code&gt; index you generated earlier into your &lt;code&gt;indexes/&lt;/code&gt; folder.  (This can really be anywhere, it will always look for an &lt;code&gt;indexes/&lt;/code&gt; folder relative to the current working directly when you launch &lt;code&gt;bleve-hosted&lt;/code&gt;.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Restart &lt;code&gt;bleve-hosted&lt;/code&gt; and optionally configure your server to keep this process running long term (init-scripts, etc)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;add-search-to-your-site:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Add Search to your Site&lt;/h3&gt;

&lt;p&gt;Finally, we&amp;rsquo;re ready to add a search page to our site.  Several files were downloaded as a part of the &lt;code&gt;hugoidx&lt;/code&gt; package to help you get started.  Feel free to customize these files to best adapt them to your site.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cd &amp;lt;your hugo site&amp;gt;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy the main search page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp $GOPATH/src/github.com/blevesearch/hugoidx/search.md content/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy support JavaScript files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p static/js/
cp $GOPATH/src/github.com/blevesearch/hugoidx/handlebars.js static/js/
cp $GOPATH/src/github.com/blevesearch/hugoidx/search.js static/js/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handlebars.js is used to render search results using a simple template syntax.&lt;br /&gt;
search.js is our custom code to bind everything together.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If your site is not already using jQuery:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp $GOPATH/src/github.com/blevesearch/hugoidx/jquery.min.js static/js/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery is used to make AJAX requests from the browser to &lt;code&gt;bleve-hosted&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update your layout to include these javascript files.  For many sites this will be in a file like &lt;code&gt;layouts/partial/footer.html&lt;/code&gt; or &lt;code&gt;themes/&amp;lt;your theme&amp;gt;/layouts/partials/footer.html&lt;/code&gt;.  In the section where javascript files are being included you&amp;rsquo;ll want to add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;/js/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;/js/handlebars.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;/js/search.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, we need to update search.js to point to the correct URL for &lt;code&gt;bleve-hosted&lt;/code&gt;.  On line 2 of &lt;code&gt;static/js/search.js&lt;/code&gt; modify the value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var searchURL = &#39;http://&amp;lt;your server&amp;gt;:8080/api/search.bleve/_search&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;try-it-out:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Try it Out&lt;/h3&gt;

&lt;p&gt;Now, you&amp;rsquo;re ready to regenerate your site and try it out.  If you open your browser to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://localhost:1313/search
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see the standard search box.  If you type in your query, the page should reload and display search results below.  If you run into problems, it may be helpful to view the javascript console.&lt;/p&gt;

&lt;h3 id=&#34;finishing-touches:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Finishing Touches&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s also add search to the navigation bar.  For our site, we modified the partial &lt;code&gt;navbar.html&lt;/code&gt; to include the following inside the navigation unordered-list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;div class=&amp;quot;dropdown pull-right&amp;quot;&amp;gt;
      &amp;lt;form class=&amp;quot;navbar-form&amp;quot; role=&amp;quot;search&amp;quot; action=&amp;quot;/search&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;input-group&amp;quot;&amp;gt;
            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;Search&amp;quot; name=&amp;quot;q&amp;quot; id=&amp;quot;srch-term&amp;quot;&amp;gt;
            &amp;lt;div class=&amp;quot;input-group-btn&amp;quot;&amp;gt;
                &amp;lt;button class=&amp;quot;btn btn-default&amp;quot; type=&amp;quot;submit&amp;quot;&amp;gt;&amp;lt;i class=&amp;quot;glyphicon glyphicon-search&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;future:0bce37434e78e28d05902c6ccb8f2171&#34;&gt;Future&lt;/h3&gt;

&lt;p&gt;Is this perfect? No, not really, there are a still a lot of rough edges we&amp;rsquo;d like to smooth out.  Here are some of our ideas for the future:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Enable running &lt;code&gt;bleve-hosted&lt;/code&gt; in Google App Engine.  This lowers the bar for hosting your index.&lt;/li&gt;
&lt;li&gt;Streamline the addition of search to your site.  The manual copying of multiple files and editing paths is error prone.  Perhaps additional sub-commands of &lt;code&gt;hugoidx&lt;/code&gt; could assist with this.&lt;/li&gt;
&lt;li&gt;Document worklfow for keeping your site AND your search index up to date.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Having problems with these instructions?  Let us know via &lt;a href=&#34;mailto:info@blevesearch.com&#34;&gt;email&lt;/a&gt; or the &lt;a href=&#34;https://groups.google.com/forum/#!forum/bleve&#34;&gt;Google Group&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Site Migrated to Hugo</title>
      <link>https://www.blevesearch.com/news/Site-Migrated-to-Hugo/</link>
      <pubDate>Thu, 02 Jul 2015 10:25:38 -0400</pubDate>
      
      <guid>https://www.blevesearch.com/news/Site-Migrated-to-Hugo/</guid>
      <description>

&lt;p&gt;You may notice the site looks a little different today.  We&amp;rsquo;ve just launched a version of the site built with &lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;.  The site is functional, but still also very much a work in progress.  Don&amp;rsquo;t hesitate to report any problems you find.&lt;/p&gt;

&lt;h3 id=&#34;why-did-we-make-the-change:871bbe6ca1368764a58ff754bed0e978&#34;&gt;Why did we make the change?&lt;/h3&gt;

&lt;p&gt;Our initial site was just a set of 3 static HTML files.  With so few files, it was reasonable to just copy/paste the headers/footers, etc.  But Bleve is growing, and as we continue to progress our site needs more pages.  Moving beyond just a few pages requires us to use some automation.  I&amp;rsquo;ve used Hugo to build small sites in the past and it&amp;rsquo;s worked great.  And we&amp;rsquo;re happy to support another Go project.&lt;/p&gt;

&lt;h3 id=&#34;site-changes:871bbe6ca1368764a58ff754bed0e978&#34;&gt;Site Changes&lt;/h3&gt;

&lt;p&gt;For the most part you&amp;rsquo;ll find the current site looks similar to the previous site.  The biggest change is that we&amp;rsquo;ve moved our documentation from the Github Wiki into the website itself.  Initially we liked the idea of using the wiki for documentation, particularly because it has such a low bar for users to contribute content.  But, with very little contribution actually happening, we feel there will be more benefits to bringing it into the website.&lt;/p&gt;

&lt;h3 id=&#34;what-about-search:871bbe6ca1368764a58ff754bed0e978&#34;&gt;What about Search?&lt;/h3&gt;

&lt;p&gt;Previously we offered an integrated github wiki search on the website, and as of today that is now missing.  However, stay tuned for future announcements!  Bleve site and documentation search will be back.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>